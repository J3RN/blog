[{"content":"","date":"May 11, 2023","permalink":"/tags/databases/","section":"Tags","summary":"","title":"databases"},{"content":"","date":"May 11, 2023","permalink":"/","section":"J3RN's Blog","summary":"","title":"J3RN's Blog"},{"content":"","date":"May 11, 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"May 11, 2023","permalink":"/tags/software-development/","section":"Tags","summary":"","title":"software development"},{"content":"","date":"May 11, 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"If you\u0026rsquo;ve been writing relational database-backed applications for long enough, you\u0026rsquo;ve needed this. The situation is common enough: You have a some kind of web application, you don\u0026rsquo;t want to have any downtime, and you need to make a breaking change to your schema.\nBreaking changes come in several forms: renaming a column, changing its type, or even just changing the format in which you store data (e.g. normalizing phone numbers), etc. What these cases have in common is that once the change is made, the code that relied on the way that things were will no longer function. For instance, when a column is renamed, code that\u0026rsquo;s looking for the data under the old name won\u0026rsquo;t work. Code looking for data under the new name won\u0026rsquo;t function either until the rename is complete. One approach would be to design your system to try the new column name first and fall back to the old column name in the case that the new one doesn\u0026rsquo;t exist, but the ORMs I\u0026rsquo;ve used (ActiveRecord and Ecto) don\u0026rsquo;t natively support this; they generally cause errors when a column you said exists doesn\u0026rsquo;t. Thus—for a while—we\u0026rsquo;ll need both the old column (or table, or format, or whatever) to exist alongside the new column (or table, or format, or whatever).\nFor the remainder of this article, I\u0026rsquo;ll be using the example of renaming a database table. I hope the mapping is clear for other kinds of breaking changes and I will try to add some pointers where approaches may diverge.\nLet\u0026rsquo;s say that you\u0026rsquo;ve got a table named \u0026ldquo;inovices.\u0026rdquo; Whoops! Somebody misspelled that! Well it\u0026rsquo;s in production now, but the team wants to rename this table to \u0026ldquo;invoices\u0026rdquo; so that it\u0026rsquo;s less confusing.\nPart 1: Write Twice, Read Old # Fight the impulse to ALTER TABLE inovices RENAME TO invoices—this will break the running code! Instead, create a new invoices table with an identical schema. Now our old code can use the old, misspelled table at the same time as our new code can (theoretically) use the new, correctly spelled, table.\n But wait, these two tables don\u0026rsquo;t have the same data in them!\n Yes, that\u0026rsquo;s a problem we\u0026rsquo;ll need to fix. The first step is to update our application such that when we add new rows to, or update the existing rows of, the old inovices table, we also write that data to the new invoices table. This way, all data created or updated after this first step is deployed will be available in both tables.\n In the case of \"renaming\" tables, it's important that records across the two tables share primary keys. Keys are how records in relational databases relate to one another, so it's important that when we swap out the new table for the old one, our relationships don't break! If you're using your SQL database to generate your primary keys, you'll likely want to store new rows in the old table first, returning their primary keys, and then specify those primary keys explicitly when storing those rows in the new table.  Also, it should probably be intuitive here that our application, while writing to both new and old tables, should only be reading from the old (inovices) table. That\u0026rsquo;s the only table that has all our data in it!\nAlright, once we\u0026rsquo;ve created the new table and updated our application to write twice but still read from the old source, we can now deploy this chunk of work.\nPart 2: Backfill # Ah yes, the glamour-less backfill task. Now that Part 1 is deployed, our new table is being populated with new data, but it\u0026rsquo;s still missing all the old data that the old inovices table has! Time to fix that.\nThere\u0026rsquo;s no cross-framework standard on how to write backfill tasks—and heck, you could just connect to the database directly and perform this operation—but the idea here is simply that for each record in the old table (or column or whatever), we need to create a corresponding record in the new table (or column or whatever). I trust that you can figure this out for yourself.\nWhen this backfill task is finished running, the data inside the two tables should be identical. And, since we\u0026rsquo;re writing identical data to both, they should stay in-sync.\nPart 3: Read New, Stop Writing Old # This is probably the most gratifying step! Here we update our application to forget that the old, misspelled inovices table ever existed. We can read from the new—properly spelled—table because it\u0026rsquo;s got all the same data in it, and we don\u0026rsquo;t have to write to the old table anymore because we\u0026rsquo;re not reading it anymore and never will again!\nPart 4: Delete Old # Once the deploy of Part 3 is complete, our application is no longer attempting to read or write to the old table. Thus, we\u0026rsquo;re free to drop it! Run DROP TABLE inovices at your discretion.\nConclusion # Admittedly, the Four Part Migration isn\u0026rsquo;t very fun or glamorous. However, in my experience this is the only safe way I\u0026rsquo;ve seen to make a breaking change to your schema without downtime (specifically looking at you, blue/green deployments). I hope this post helps you solve your schema change conundrum!\nI don\u0026rsquo;t have comments on my blog, but if you have feedback, please reach out to me on Mastodon/Fedi!\n","date":"May 11, 2023","permalink":"/posts/the-four-part-migration/","section":"Posts","summary":"If you\u0026rsquo;ve been writing relational database-backed applications for long enough, you\u0026rsquo;ve needed this. The situation is common enough: You have a some kind of web application, you don\u0026rsquo;t want to have any downtime, and you need to make a breaking change to your schema.\nBreaking changes come in several forms: renaming a column, changing its type, or even just changing the format in which you store data (e.g. normalizing phone numbers), etc.","title":"The Four Part Migration"},{"content":"","date":"March 1, 2023","permalink":"/tags/debugging/","section":"Tags","summary":"","title":"debugging"},{"content":"Sometimes, either in local development or on a production server, you want to see when a given function is called, what arguments it is being called with, and what it\u0026rsquo;s returning. Let\u0026rsquo;s say that you have a MyApp.Widgets.show_widget?/1 function which consumes a widget and returns a boolean indicating whether or not that widget should be shown to the user. However, the logic contained in there is pretty complicated and—worse—you don\u0026rsquo;t know really where it is called from anyway.\nIf you\u0026rsquo;re like me, you\u0026rsquo;ve taken to littering your functions with IO.puts and IO.inspect to get this information. However, there\u0026rsquo;s an cleaner way!\nEnter Erlang\u0026rsquo;s dbg, a module that uses Erlang\u0026rsquo;s powerful tracing system to print events of interest to the console. Its usage in this article works regardless of whether you\u0026rsquo;re using an IEx prompt or injecting this code into a test.\nTo use dbg to solve our mysteries, we\u0026rsquo;ll first have to start its tracer process1:\n:dbg.tracer() Next, we\u0026rsquo;ll need to tell dbg what to look for, which we do with the unusually terse p function (all function names in dbg are, for some reason, very terse):\n:dbg.p(:all, :call) The function name p is supposedly short for \u0026ldquo;process\u0026rdquo;, and its purpose is to tell dbg which tracer events we\u0026rsquo;re interested in. The first argument tells dbg which process(es) you want to trace. You can pass a PID here to trace a specific process, but in the example we\u0026rsquo;re passing the atom :all to indicate that we want events from all processes. There are other special atoms you can use to indicate groups of processes, such as :new_processes; check the :dbg.p/2 documentation for a full list. The second argument specifies which kinds of tracer events you want to be notified about. :call indicates that we want to know about function calls, and there are other options such as :send for message sending, :ports for things related to ports, etc.\nWell, dbg refuses to print information about every function call being made in the system—at least, unless you ask it to—so in addition to telling dbg to trace function calls across all processes, we\u0026rsquo;ll need to specify which function calls it should trace. We\u0026rsquo;ll do that here with the tpl function:\n:dbg.tpl(MyApp.Widgets, :show_widget?, :x) The function name tpl is short for \u0026ldquo;trace pattern local.\u0026rdquo; The first two arguments indicate, as you probably guessed, the module and function that you want to trace. That mysterious :x? We\u0026rsquo;ll get to that in a moment.\n ⚠️ Note # If you reload the module given as the first argument to :dbg.tpl/3, either manually with the IEx r helper or via Phoenix\u0026rsquo;s built-in code reloader, you\u0026rsquo;ll need to run :dbg.tpl/3 again. I don\u0026rsquo;t know why this is exactly, and it can be pretty annoying.\n The dbg docs will generally point you towards using tp. The difference between tp and tpl is that tp only traces \u0026ldquo;global\u0026rdquo; calls—calls between modules—and tpl traces both global and \u0026ldquo;local\u0026rdquo; (intra-module) calls. I\u0026rsquo;m generally a \u0026ldquo;more data is better\u0026rdquo; person, so I prefer tpl.\nThat\u0026rsquo;s all the setup we need to start debugging! After this code has been evaluated in a running system, events that match our \u0026ldquo;pattern\u0026rdquo; (here, calls of the function MyApp.Widgets.show_widget/1 in any process) will be printed to the console. Here\u0026rsquo;s an example:\niex(4)\u0026gt; MyApp.Widgets.show_widget?(%MyApp.Widget{spurving_bearings: false}) # (\u0026lt;0.187.0\u0026gt;) call \u0026#39;Elixir.MyApp.Widgets\u0026#39;:\u0026#39;show_widget?\u0026#39;(#{\u0026#39;__struct__\u0026#39; =\u0026gt; \u0026#39;Elixir.MyApp.Widget\u0026#39;,hydrocoptic_marzelvanes =\u0026gt; nil, # spurving_bearings =\u0026gt; false}) # (\u0026lt;0.187.0\u0026gt;) returned from \u0026#39;Elixir.MyApp.Widgets\u0026#39;:\u0026#39;show_widget?\u0026#39;/1 -\u0026gt; false false As you can see above, dbg prints out that our function was called, what arguments it was called with, and what the function returned. This is not super exciting since we called it manually, but when you\u0026rsquo;re at least one step removed\u0026hellip;\niex(5)\u0026gt; MyApp.list_widgets() # (\u0026lt;0.187.0\u0026gt;) call \u0026#39;Elixir.MyApp.Widgets\u0026#39;:\u0026#39;show_widget?\u0026#39;(#{\u0026#39;__struct__\u0026#39; =\u0026gt; \u0026#39;Elixir.MyApp.Widget\u0026#39;, # hydrocoptic_marzelvanes =\u0026gt; [a,b,c,d,e,f], # spurving_bearings =\u0026gt; true}) # (\u0026lt;0.187.0\u0026gt;) returned from \u0026#39;Elixir.MyApp.Widgets\u0026#39;:\u0026#39;show_widget?\u0026#39;/1 -\u0026gt; true [  %MyApp.Widget{  spurving_bearings: true,  hydrocoptic_marzelvanes: [:a, :b, :c, :d, :e, :f]  } ] we can see that MyApp.Widgets.show_widget?/1 was called, what it was passed, and what it returned.\nOK, let\u0026rsquo;s talk about :x. The third argument to tpl is a \u0026ldquo;Match Spec\u0026rdquo;. Match specifications are non-trivial, and if you want to learn more about them you can do that here: Match Specifications in Erlang. Luckily for us, tpl has a few \u0026ldquo;built-in aliases\u0026rdquo; for debugging-related match specs, of which :x is one. Here, :x is short for \u0026ldquo;exceptions,\u0026rdquo; which is also a bit deceiving since, in addition to reporting exceptions, it also reports calls, arguments, and return values. The other two built-in aliases are :c and :cx. :c is short for \u0026ldquo;caller\u0026rdquo; and it reports the function that called your function of interest:\niex(7)\u0026gt; MyApp.list_widgets() # (\u0026lt;0.187.0\u0026gt;) call \u0026#39;Elixir.MyApp.Widgets\u0026#39;:\u0026#39;show_widget?\u0026#39;(#{\u0026#39;__struct__\u0026#39; =\u0026gt; \u0026#39;Elixir.MyApp.Widget\u0026#39;, # hydrocoptic_marzelvanes =\u0026gt; [a,b,c,d,e,f], # spurving_bearings =\u0026gt; true}) ({\u0026#39;Elixir.Enum\u0026#39;,filter_list,2}) [  %MyApp.Widget{  spurving_bearings: true,  hydrocoptic_marzelvanes: [:a, :b, :c, :d, :e, :f]  } ] At the very end of the output you can see that ({'Elixir.Enum',filter_list,2}) is the function that called MyApp.Widgets.show_widget?/1. That nice to know, but you may have noticed that :c doesn\u0026rsquo;t report the return value. If you want both the caller and the return value, :cx is for you:\niex(9)\u0026gt; MyApp.list_widgets() # (\u0026lt;0.187.0\u0026gt;) call \u0026#39;Elixir.MyApp.Widgets\u0026#39;:\u0026#39;show_widget?\u0026#39;(#{\u0026#39;__struct__\u0026#39; =\u0026gt; \u0026#39;Elixir.MyApp.Widget\u0026#39;, # hydrocoptic_marzelvanes =\u0026gt; [a,b,c,d,e,f], # spurving_bearings =\u0026gt; true}) ({\u0026#39;Elixir.Enum\u0026#39;,filter_list,2}) # (\u0026lt;0.187.0\u0026gt;) returned from \u0026#39;Elixir.MyApp.Widgets\u0026#39;:\u0026#39;show_widget?\u0026#39;/1 -\u0026gt; true [  %MyApp.Widget{  spurving_bearings: true,  hydrocoptic_marzelvanes: [:a, :b, :c, :d, :e, :f]  } ] One final note before you go: You may have noticed that the reports from dbg use Erlang syntax, and that\u0026rsquo;s for the very good reason that dbg is an Erlang utility and knows nothing about Elixir and its syntax. Printing to the console is performed by a \u0026ldquo;handler\u0026rdquo; function which is an optional argument to dbg:tracer. By default the handler function is dbg:dhandler/2, but there\u0026rsquo;s no reason why an Elixir-formatting handler couldn\u0026rsquo;t be written. That said, dbg:dhandler/2 (and it\u0026rsquo;s closely associated dhandler1/3) constitute nearly 200 lines of code, so it\u0026rsquo;s no small task!\nI hope you found this information useful and happy debugging!\n  The process spawned by :dbg.tracer() (aptly named dbg) listens for events from Erlang\u0026rsquo;s tracing system.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"March 1, 2023","permalink":"/posts/2023-03-01-debugging-with-dbg/","section":"Posts","summary":"Sometimes, either in local development or on a production server, you want to see when a given function is called, what arguments it is being called with, and what it\u0026rsquo;s returning. Let\u0026rsquo;s say that you have a MyApp.Widgets.show_widget?/1 function which consumes a widget and returns a boolean indicating whether or not that widget should be shown to the user. However, the logic contained in there is pretty complicated and—worse—you don\u0026rsquo;t know really where it is called from anyway.","title":"Debugging Elixir with Erlang's dbg"},{"content":"","date":"March 1, 2023","permalink":"/tags/elixir/","section":"Tags","summary":"","title":"elixir"},{"content":"","date":"March 1, 2023","permalink":"/tags/erlang/","section":"Tags","summary":"","title":"erlang"},{"content":"","date":"September 4, 2022","permalink":"/tags/c/","section":"Tags","summary":"","title":"c"},{"content":"","date":"September 4, 2022","permalink":"/tags/clojure/","section":"Tags","summary":"","title":"clojure"},{"content":"","date":"September 4, 2022","permalink":"/tags/language-design/","section":"Tags","summary":"","title":"language design"},{"content":"For me, clarity is composed of two smaller ideas: readability and comprehensibility. Neither of these words have widely-accepted definitions in software engineering, so for the purposes of this article, I will define them like so:\n readability ability for a reader to recognize the syntactic constructs in a body of code. comprehensibility ability for a reader to discern the what a body of code does at a high level.  Readability # The LISP family of programming languages have reached the pinnacle of readability.\nConsider that in Clojure (a LISP) addition looks like this:\n(+ 1 2) Printing to the console looks like this:\n(println \u0026#34;Hello, World!\u0026#34;) \u0026ldquo;If\u0026rdquo; expressions look like this:\n(if true :was-true :was-false) In each case, the expression has the form (\u0026lt;function\u0026gt; \u0026lt;arg1\u0026gt; \u0026lt;arg2\u0026gt; ...). That\u0026rsquo;s it! Now you can parse any line of LISP.\nContrast this with a language such as C where addition looks like this:\n1 + 2 Printing to the console looks like this:\nprintf(\u0026#34;Hello, World!\u0026#34;); \u0026ldquo;If\u0026rdquo; statements look like this:\nif (condition) {  // perform \u0026#34;then\u0026#34; actions } else {  // perform \u0026#34;else\u0026#34; actions } Each of these statements and expressions uses a different syntax (infix operator, function invocation, multi-arm conditional), and these are not the only forms in the language either. After years of study, many C programmers believe they have learned all the syntax of the language only to be bewildered by ternary expressions.\nComprehensibility # Readability, however, is often in contention with comprehensibility. Let\u0026rsquo;s compare two recursive implementations of a factorial function:\nClojure\n(defn factorial [x]  (if (\u0026lt;= x 1)  1  (* x (factorial (- x 1))))) C1\nint factorial(int x) {  if (x \u0026lt;= 1) return 1;  else return x * factorial(x - 1); } The uniformity of the syntax of expressions in LISPs such as Clojure can impair the reader\u0026rsquo;s ability to quickly determine the meaning of a given expression. For instance, the prefix notation of LISPs applied to boolean and arithmetic operators (e.g. \u0026lt; a b) can be difficult for the reader to decipher when they are used to seeing infix notation (e.g. a \u0026lt; b).\nBy contrast, the diversity of syntactic forms in the presented C code (discussed above), with the exception of the noisy inline type specifications, lead to a very comprehensible function (at least in my opinion). With only a little imagination, the function\u0026rsquo;s body can be read as the English sentence \u0026ldquo;If x is less than one, return one; else return x times the factorial of x minus one.\u0026rdquo; If I had to explain to someone how this function worked, that is almost precisely the language that I would use to do so (although I would probably say \u0026ldquo;otherwise\u0026rdquo; instead of \u0026ldquo;else\u0026rdquo;).\nHowever, if I had to explain which syntactic forms were utilized in the C function, I would have substantially more difficulty (infix operators, explicit return, braceless conditional?).\nWrap Up # While the syntax of a language can make a significant impact on the readability and comprehensibility of programs written in that language, a great deal of the burden of writing comprehensible code falls on the author in the form of code style, application architecture, and code organization. For instance, consider this ~200 line Go function in the Lightning Network Daemon. How long would it take you to understand or explain how this function works? I\u0026rsquo;m guessing quite a while. As such, I hope to explore further how authors can make their codebases more comprehensible.\n  If you write C, you probably have your own preferred style and this is certainly not it. Bear with me here.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"September 4, 2022","permalink":"/posts/2022-05-13-readability-vs-comprehensibility/","section":"Posts","summary":"For me, clarity is composed of two smaller ideas: readability and comprehensibility. Neither of these words have widely-accepted definitions in software engineering, so for the purposes of this article, I will define them like so:\n readability ability for a reader to recognize the syntactic constructs in a body of code. comprehensibility ability for a reader to discern the what a body of code does at a high level.  Readability # The LISP family of programming languages have reached the pinnacle of readability.","title":"Readability vs Comprehensibility"},{"content":"Just as Protocols are an abstraction built upon Behaviours, Agents are an abstraction built upon GenServers. While GenServers can serve a wider variety of purposes, Agents serve a single purpose: storing state.\nGenServer # The Elixir documentation for GenServer summarizes them as such:\n A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.\n Included in this summary are two potential use-cases for GenServers:\n Keep state Execute code asynchronously  Let\u0026rsquo;s explore each of these.\nKeeping State # When the documentation refers to \u0026ldquo;keeping state,\u0026rdquo; it means between processes. In Elixir, data structures cannot (at least not without some trickery) be shared between processes; each process has it\u0026rsquo;s own data, and the only way to share data between processes is by passing messages (e.g. using send/2). This frees Elixir developers from having to worry about race conditions much of the time, but it also creates a new question of how to allow multiple processes within an Elixir system to have read/write access to a shared piece of data. I have included an example for doing this with both GenServers and Agents in the latter half of this post.\nExecuting Code Asynchronously # The idea here is simple: imagine a web request process wants a report to be generated and an email sent, but also doesn\u0026rsquo;t want to have to wait until those are finished before sending a response to the user.\nEnter GenServer. When an application has a dedicated GenServer process to perform a specific task, other processes can request the GenServer to perform its task by sending it a message, and then continue on with their other work1.\nWhile doing this with Agent is possible it\u0026rsquo;s not the intended use of Agent, and so should be avoided.\nAgent # The Elixir documentation for Agent summarizes them simply as:\n Agents are a simple abstraction around state.\n The commentary around \u0026ldquo;Keeping State\u0026rdquo; from the GenServer section above applies here, with the noted caveat that Agents are optimized for this use case.\nFeature Comparison # Agents surface much, but not all, of the functionality from their underlying GenServers.\n   Feature GenServer Support Agent Support     call (send message and await response) Yes Yes   cast (send message without waiting for response) Yes Yes   info (receive arbitrary messages sent with send/2) Yes No   continue (init function can continue async) Yes No   terminate (custom behavior on shutdown) Yes No   code change (custom code update handling) Yes Sort-of    Additionally, the Agent module provides a variety of Access-like functions that help the user think of it as a datastructure instead of a process, such as:\n get/3, get/5 update/3, update/5 get_and_update/3, get_and_update/5  The utility of these, and the advantages they provide over coding the same functionality with a GenServer, is best shown through an example.\nExample # Let\u0026rsquo;s say that we\u0026rsquo;re creating a bulletin board where users can post new messages. Each request that comes into the bulletin board system is either posting a new message or reading the messages that have been posted.\n   With Phoenix, as well as with other Elixir/Erlang web frameworks, each request is handled in its own process. Thus, the request-handling process\u0026rsquo; state will only include a few things that have been given to it—most likely not including our repository of messages. These request processes need to be able to read or write to a shared repository of messages.\nLet\u0026rsquo;s create a GenServer to hold the messages2!\nConventionally, the first place to start is by defining a module and calling use GenServer within it:\ndefmodule BBS.MessageRepository do  use GenServer Next, we\u0026rsquo;ll define our server functionality. This consists of an init/1 function which is invoked when the server starts up and a handle_call/3 function which is invoked when the server receives a message3.\n # Server   def init(messages) do  {:ok, messages}  end   def handle_call({:post, message}, _from, messages) do  {:reply, :ok, [message | messages]}  end   def handle_call(:read_all, _from, messages) do  {:reply, messages, messages}  end Our init/1 allows the server to be initialized with a list of messages, which we use as the initial state. The return value {:ok, messages} indicates that the server started successfully and we want our GenServer\u0026rsquo;s state to be messages.\nOur handle_call/3 function can handle two kinds of incoming messages:\n {:post, message}, which requests that message be posted to the bulletin board :read_all, which requests all of the messages on the bulletin board  The return value in both cases takes the form {:reply, response, new_state}. There are other allowable formats for return values of handle_call/2, but this is the only one we need for this example.\nIf we ended our module here, a client could use this code like so:\niex(1)\u0026gt; {:ok, pid} = GenServer.start_link(BBS.MessageRepository, [\u0026#34;Welcome to My Bulletin Board!\u0026#34;]) {:ok, #PID\u0026lt;0.163.0\u0026gt;} iex(2)\u0026gt; GenServer.call(pid, {:post, \u0026#34;Block Party!\u0026#34;}) :ok iex(3)\u0026gt; GenServer.call(pid, :read_all) [\u0026#34;Block Party!\u0026#34;, \u0026#34;Welcome to My Bulletin Board!\u0026#34;] Your PID will almost certainly be different—this is to be expected!\nThis isn\u0026rsquo;t very convenient, though, and each request process shouldn\u0026rsquo;t call GenServer.start_link start it\u0026rsquo;s own server—that would defeat the purpose!—they need to share one server.\nLet\u0026rsquo;s fix this by configuring our application start the server. If your Elixir app was generated with a supervision tree (i.e. you passed --sup to mix new or are using Phoenix/another framework), you should have an application.ex file, e.g. lib/bbs/application.ex. This file is where the application\u0026rsquo;s supervision tree is defined, and processes specified in the list of children will be started when your application boots. Let\u0026rsquo;s add our message repository as a child in this list.\n children = [  %{  id: BBS.MessageRepository,  start:  {GenServer, :start_link,  [  BBS.MessageRepository,  [\u0026#34;Welcome to My Bulletin Board!\u0026#34;],  [name: BBS.MessageRepository]  ]}  }  ] This is a bit verbose, but we\u0026rsquo;ll clean it up later. The key concept here is that the children list should be reducible to a list of maps that at least have an :id key—whose value is used internally by the supervisor to identify this child—and a :start key—whose value is a Module-Function-Arguments (MFA) tuple that indicates what function to call to start the process.\nYou may have noticed that [name: BBS.MessageRepository] was added as a third argument to GenServer.start_link. When :name refers to an atom (and in Elixir, modules are atoms), that atom is registered as the node-local name for the process. With the name registered, we can use the name instead of the PID when invoking GenServer.call/2 (and other process communication functions such as send/2). By convention, the name of the module that defines the process is used as the process name.\nWith this in place, our application will start a shared message repository which we can immediately access by its name:\niex(1)\u0026gt; GenServer.call(BBS.MessageRepository, {:post, \u0026#34;Block Party!\u0026#34;}) :ok iex(2)\u0026gt; GenServer.call(BBS.MessageRepository, :read_all) [\u0026#34;Block Party!\u0026#34;, \u0026#34;Welcome to My Bulletin Board!\u0026#34;] This works pretty well. However, it\u0026rsquo;s conventional in Elixir to use wrapper \u0026ldquo;client\u0026rdquo; functions instead of calling GenServer functions directly from your application code. This is especially important when data flowing from your application into the GenServer or vice versa require a bit of processing. That\u0026rsquo;s not the case for us, but we\u0026rsquo;ll define client functions anyways for the sake of convention. We\u0026rsquo;ll put these below the server functions in the BBS.MessageRepository module4.\n # Client   def post(message) do  GenServer.call(BBS.MessageRepository, {:post, message})  end   def read_all() do  GenServer.call(BBS.MessageRepository, :read_all)  end Now, from anywhere in our application we can simply invoke BBS.MessageRepository.post(\u0026quot;Block Party!\u0026quot;) to post a message about a block party and BBS.MessageRepository.read_all() to read all existing messages. Not too shabby!\nYou can view this first iteration of BBS.MessageRepository on GitHub.\nLastly, the cleanup I mentioned before. At the very bottom of our BBS.MessageRepository module we can define a start_link/1 function like so:\n def start_link(messages) do  GenServer.start_link(  BBS.MessageRepository,  messages,  name: BBS.MessageRepository  )  end end The key incentive to doing this is that it allows us to simplify the specification for this process in the children list of the application supervisor:\n children = [  {BBS.MessageRepository, [\u0026#34;Welcome to My Bulletin Board!\u0026#34;]}  ] Additionally, moving the logic regarding how the process starts into the module where other aspects of process are defined lowers the coupling from our application module to our process module. For instance, if we wanted to change how the BBS.MessageRepository process was started (cough foreshadowing cough), we would only have to update the BBS.MessageRepository module.\nYou can view this slightly expanded BBS.MessageRepository and the terser application.ex on GitHub.\n How Does Specifying a Child with a Tuple Work? # Unfortunately, it\u0026rsquo;s a bit complicated.\nPer the Supervisor documentation, children can be specified by:\n A map, as discussed previously A module A {module, arg} tuple, as used above A six-element tuple (deprecated)  The list of child specifications is passed to Supervisor.start_link/2, where they are passed to Supervisor.init/2, and subsequently to Supervisor.init_child/1 (private), which is responsible for turning each of these into the previously discussed map format (except for the sextuple format, but I\u0026rsquo;m ignoring that because it\u0026rsquo;s deprecated).\nWhen Supervisor.init_child/1 is given a map, its work is already complete and the map is returned without any changes. When only a module is given, it is wrapped in a tuple with an empty list and passed again to Supervisor.init_child/1. When a tuple containing a module and some second element (\u0026ldquo;the argument\u0026rdquo;) is given, Supervisor.init_child/1 assumes that the module defines a child_spec/1 function that, when called with the argument, will return the desired map.\n\u0026ldquo;But wait,\u0026rdquo; you say, \u0026ldquo;we didn\u0026rsquo;t define a child_spec/1 function in BBS.MessageRepository!\u0026rdquo; You\u0026rsquo;re correct. However, when we invoke use GenServer at the top of the BBS.MessageRepository module, GenServer\u0026rsquo;s __using__ macro is invoked, which defines a child_spec/1 for us. This generated child_spec/1 function returns a map that specifies the module\u0026rsquo;s name as the :id—which we did before, so that\u0026rsquo;s fine—and refers to a local start_link/1 function for the :start key. Thus, we needed to define a start_link/1 function to start our server process, which we did above.\nYou can override this generated child_spec/1 function by simply defining such a function within the module body, if needed.\nThis functionality allows us to avoid some boilerplate when specifying children processes for a supervisor and avoid the aforementioned coupling, but comes at the cost of being a bit convoluted when you\u0026rsquo;re trying to figure out how it works.\n This wraps up a basic example of storing state with a GenServer.\nLet\u0026rsquo;s refactor our BBS.MessageRepository module to use Agent instead of GenServer. Firstly, we\u0026rsquo;ll change use GenServer to use Agent:\ndefmodule BBS.MessageRepository do  use Agent Easy enough! Next, we\u0026rsquo;ll need to change our init/1 function very subtly:\n # Server   def init(messages) do  messages  end Did you notice the change? We changed the return value from {:ok, messages} to just messages. Agents don\u0026rsquo;t appear to have a method to specify that the server initialization failed, whereas GenServers\u0026rsquo; init/1 may return :ignore or {:stop, reason} to indicate that the server should not be started. Regardless, this isn\u0026rsquo;t a problem for us in this example.\nNext, we\u0026rsquo;re going to convert our handle_call/2 function clauses into two new functions: handle_post/2 and handle_read_all/1. You\u0026rsquo;ll see why this is necessary soon.\n def handle_post(messages, message) do  [message | messages]  end   def handle_read_all(messages) do  messages  end Again, we\u0026rsquo;ve been able to dispose of some syntactic noise—we don\u0026rsquo;t take from as an argument (which we didn\u0026rsquo;t use anyways) and don\u0026rsquo;t have to wrap our return values in {:reply, response, new_state} tuples. Speaking of which, something interesting to note is that handle_post/2 returns only the new state and handle_read_all/1 only returns a response for the client (which is coincidentally also the state here, but doesn\u0026rsquo;t need to be). These functions also now take different numbers of arguments! These changes are facilitated by the Agent functions we\u0026rsquo;ll be using in our updated client functions.\n # Client   def post(message) do  Agent.update(BBS.MessageRepository, BBS.MessageRepository, :handle_post, [message])  end   def read_all() do  Agent.get(BBS.MessageRepository, BBS.MessageRepository, :handle_read_all, [])  end In post/1, we make use of Agent.update which takes the name of a running Agent as the first argument—we\u0026rsquo;re still naming the process after the module, per convention—and a module, function, and arguments for the next three arguments (essentially an MFA tuple, discussed earlier). The specified function will receive the Agent\u0026rsquo;s state as its first argument and the arguments specified in the Agent.update call as subsequent arguments. The return value of this function will be the new state for the Agent. Agent.update always returns :ok.\nThe implementation of read_all is similar, except that the return value of the function specified to Agent.get will be the return value of Agent.get and has no impact on the Agent\u0026rsquo;s state.\nA nicety of this approach is the ability to assign arbitrary names to the handler functions, whereas with GenServer they had to be clauses of the handle_call function.\nLastly, let\u0026rsquo;s update our start_link/1 function:\n def start_link(messages) do  Agent.start_link(BBS.MessageRepository, :init, [messages], name: BBS.MessageRepository)  end end This didn\u0026rsquo;t change all that much; we swapped \u0026ldquo;GenServer\u0026rdquo; for \u0026ldquo;Agent\u0026rdquo;, now have to specify that we want the init function (which was implicit before), and also need to wrap messages in a list to make our first three arguments essentially and MFA tuple. A side effect of this is that we could now pass additional arguments to init, if we wanted, or even renamed init, but that\u0026rsquo;s not necessary for this example.\nYou can view the entire module with Agent on GitHub.\n Client/Server Separation # Being able to specify the module for the handler functions makes it pretty easy to create a dedicated server module. For instance, we could move our server functions (handle_post/2, handle_read_all/1, and init/1) into a new BBS.MessageRepository.Server module and make that module\u0026rsquo;s name the second argument in the Agent.get and Agent.update function calls above and the first argument in Agent.start_link. Voila! With these changes, we would have a clear separation of what code runs inside the Agent process from what code runs in the calling (or client) process.\nWe also could have split the server functions from the client functions with our GenServer implementation, but it would be more involved.\n If you can believe it, this code can become even more concise! Instead of passing a module, function, and arguments to the Agent functions, we can pass an anonymous function instead. Here, we\u0026rsquo;ll combine our client and server functions such that the server portion is just an anonymous function inside the client functions:\ndefmodule BBS.MessageRepository do  use Agent   def post(message) do  Agent.update(BBS.MessageRepository, fn messages -\u0026gt;  [message | messages]  end)  end   def read_all() do  Agent.get(BBS.MessageRepository, fn messages -\u0026gt;  messages  end)  end   def start_link(messages) do  Agent.start_link(fn -\u0026gt; messages end, name: BBS.MessageRepository)  end end That\u0026rsquo;s it! Those 19 lines of code constitute our entire message repository process! This level of brevity is not available with GenServer, only with Agent.\nYou can view this terser Agent version on GitHub as well.\nThe downside to this condensed code, in my opinion, is that the separation between what code runs in the server process from what code runs in the client process is at its fuzziest. I can imagine confusing what runs where when giving this code a quick skim.\nConclusion # GenServers and Agents are both kinds of processes defined within Elixir. The former allows for great flexibility and different use cases whereas the latter is optimized an implementation of the former for allowing processes to read/write access to a single piece of data.\nI hope that this post has given you the knowledge to make the right choice for your application!\n  The process mailbox acts like a FIFO queue; messages sent first will be processed first. However it\u0026rsquo;s worth noting that if the receiving process dies for any reason, it\u0026rsquo;s mailbox—and thus queue of work—will be lost.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n This works well for prototyping, but you should be aware that when the GenServer process dies, all the data that it was holding will be lost. For a more persistent data store, you\u0026rsquo;ll want to use either DETS or an external database such as Redis or PostgreSQL.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n There are other kinds of messages that can be received by a GenServer—including cast messages and info messages, handled by handle_cast/2 and handle_info/2, respectively—but I only cover call messages in this post.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n I\u0026rsquo;m not a fan of having client functions and server functions in the same file, especially if they contain any amount of logic, but this is the Elixir convention. Dave Thomas explores this in his talk \u0026ldquo;I Write Bad Elixir. So Do You!\u0026rdquo;. Humorously Agent bucks the convention and splits client and server, with the Agent module containing the client functions and the Agent.Server module containing the server functions.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"August 6, 2022","permalink":"/posts/2022-08-06-genserver-vs-agent/","section":"Posts","summary":"Just as Protocols are an abstraction built upon Behaviours, Agents are an abstraction built upon GenServers. While GenServers can serve a wider variety of purposes, Agents serve a single purpose: storing state.\nGenServer # The Elixir documentation for GenServer summarizes them as such:\n A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting.","title":"Elixir GenServers vs Agents"},{"content":"In an introductory computer science course, our professor instructed us:\n Don\u0026rsquo;t become attached to any IDE, text editor, programming language, or operating system. This field is young and constantly evolving; you don\u0026rsquo;t want to be left behind.\n I don\u0026rsquo;t think I realized at that time what tremendously insightful advice this was. At that time I was primarily writing Java in Eclipse. Over the next few years I would work professionally in PHP and Ruby and then migrate to Elixir. I would move from Eclipse to Sublime Text to Vim, and after using Vim for about four years, switch to Emacs. My current development environment (Elixir, Emacs) is fine, but there\u0026rsquo;s ample room for improvement.\nTo her credit, I think my professor probably nailed the \u0026ldquo;why\u0026rdquo; of our situation. While developers are a fickle breed, our profession has only existed for roughly seventy years and most of the tools and languages that we use are younger than we are. If this doesn\u0026rsquo;t strike you as incredible, consider that scalpels and trusses, implements used in modern medicine and bridge construction, were used by the Ancient Egyptians and Ancient Romans respectively.\nHowever, I believe that software developers can make progress as a profession by putting aside the hype—the flavor-of-the-week frameworks, the fancy features and creative syntax—and focusing on what matters.\nWhat matters? # The reason that we write software in the first place is to create solutions to problems1. Therefore, any software that doesn\u0026rsquo;t solve the stated problem within given parameters is a failure. If I were to ask a computer to tell me the trajectory needed to get a Saturn V rocket to the moon and it tells me the weather instead, I would be impressed but it would also be a complete failure as I still don\u0026rsquo;t know the answer to my question. Similarly, if the computer only produces the correct trajectory after churning for a decade, chances are I\u0026rsquo;ll have already figured it out by other methods and the effort was wasted. This combination of problem and parameters are generally referred to as \u0026ldquo;requirements\u0026rdquo;.\n   Photo by NASA on Unsplash\nSoftware developers should reach for tools (programming languages, software libraries, etc) that help them create software that meets its requirements.\nRequirements differ, but what follows are the typical kinds of requirements that I see in my day-to-day work. These are in no particular order.\nLogical Correctness # Being \u0026ldquo;logically correct\u0026rdquo; means producing the desired output; solving the problem. For instance, if I type 2 + 2 into a calculator application and it replies with 5, this is a \u0026ldquo;logical error\u0026rdquo;, and the application is not logically correct. Similarly, if I type some information into a form and click the \u0026ldquo;Save\u0026rdquo; button, this information should be persisted for later retrieval or else this, too, is a logical error.\n   Photo by Michal Marlon on Unsplash\nProductivity # While the word \u0026ldquo;productivity\u0026rdquo; lacks a widely-accepted definition in the software industry, for my purposes \u0026ldquo;productivity\u0026rdquo; refers to the amount of time and effort required to create, extend, or modify a system. Less time and effort is \u0026ldquo;more productive\u0026rdquo;, more time and effort is \u0026ldquo;less productive\u0026rdquo;.\nIf you\u0026rsquo;ve ever worked as a professional software developer, you\u0026rsquo;ll know that stakeholders always want their application completed as fast as possible. Completing functionality quickly builds confidence and goodwill with your stakeholders and can be a strategic differentiator for your company. Rather than working extra hours and foregoing relationships with family and friends, software developers should reach for tools that make creating, extending, and modifying software systems quick and effortless.\n   Photo by Lala Azizli on Unsplash\nStability # The term \u0026ldquo;stability\u0026rdquo; here means that the application does not crash. If you view a crash as \u0026ldquo;incorrect output\u0026rdquo; (e.g. a server produced a 500 response instead of the expected 200 response), one might view stability as saying \u0026ldquo;an application should be logically correct all the time and not just sometimes.\u0026rdquo;\n   Photo by Oscar Ivan Esquivel Arteaga on Unsplash\nAvailability # An application should be accessible when it is needed. If an application is only needed twice per day and is available at those times and is unavailable at all other times, it is still meeting its availability requirement (e.g. a timesheet application may have such a requirement). However, if a user tries to use a piece of software and cannot, it is not meeting its availability requirement.\n   Photo by Erik Mclean on Unsplash\nSafety # It seems that every day a company\u0026rsquo;s software systems are breached and the data that users had entrusted to them is leaked. This is an example of a system that is unsafe, whereas a system that is \u0026ldquo;safe\u0026rdquo; does not harm its users. There are a number of ways that users can be harmed by software; physically (think robotics), emotionally (think Facebook), financially (think MtGox), and others.\n   Photo by Erik Mclean on Unsplash\nSpeed # Sometimes speed is a \u0026ldquo;soft\u0026rdquo; requirement. While users would like pages to load instantaneously in their browsers, they generally will still be satisfied so long as it loads in a second or so2. In other cases, such as audio processing or transmission, a delay of even 100ms is totally untenable as the user would detect that the audio was distorted. In some extreme cases, the software speed requirement is specified down to the microsecond such that the system can interoperate with another system operating at a high, set frequency. Whatever the number is, software only meets its speed requirement if it is sufficiently fast.\n   Photo by Tsvetoslav Hristov on Unsplash\nGoing Forward # This list is not necessarily comprehensive, and I reserve the right to amend it in the future. In any event, though, I will try to tie future posts around languages and their ecosystems back to this post to show how the topic is related to a concept that matters.\n  Software is also sometimes written for fun—e.g. the TIS-100 video game or solving contrived programming puzzles—but that is not the focus of this article.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Unsurprisingly, \u0026ldquo;how fast should a page load?\u0026rdquo; features a variety of answers from \u0026ldquo;700ms\u0026rdquo; to \u0026ldquo;under 3s\u0026rdquo;. Google\u0026rsquo;s PageSpeed Insights states that a \u0026ldquo;good\u0026rdquo; First Contentful Paint (FCP) time is less than 1800ms\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"April 1, 2022","permalink":"/posts/2022-04-01-focusing-on-what-matters/","section":"Posts","summary":"In an introductory computer science course, our professor instructed us:\n Don\u0026rsquo;t become attached to any IDE, text editor, programming language, or operating system. This field is young and constantly evolving; you don\u0026rsquo;t want to be left behind.\n I don\u0026rsquo;t think I realized at that time what tremendously insightful advice this was. At that time I was primarily writing Java in Eclipse. Over the next few years I would work professionally in PHP and Ruby and then migrate to Elixir.","title":"Focusing on What Matters"},{"content":"","date":"December 5, 2021","permalink":"/tags/performance/","section":"Tags","summary":"","title":"performance"},{"content":"","date":"December 5, 2021","permalink":"/tags/profiling/","section":"Tags","summary":"","title":"profiling"},{"content":"Every now and again, you may run into a problem that isn\u0026rsquo;t hard to solve using functional programming, but which is hard to solve quickly using functional programming. For me, today, that problem was Advent of Code, Day 5.\nIf you\u0026rsquo;re participating in Advent of Code and you haven\u0026rsquo;t yet solved Day 5, this is your last chance to leave the page without spoilers. You have been warned!\nThe Problem # You are provided with a list of lines of hydrothermal vents on the ocean floor. These lines are represented by start and end coordinates, such as 0,9 -\u0026gt; 5,9. In this example, this means that there are hydrothermal vents at coordinates 0,9, 1,9, 2,9, 3,9, 4,9, and 5,9. Interestingly, two \u0026ldquo;lines\u0026rdquo; of vents may intersect or overlap, which create areas of increased concern.\nFor instance, given the input\n0,9 -\u0026gt; 5,9 8,0 -\u0026gt; 0,8 9,4 -\u0026gt; 3,4 2,2 -\u0026gt; 2,1 7,0 -\u0026gt; 7,4 6,4 -\u0026gt; 2,0 0,9 -\u0026gt; 2,9 3,4 -\u0026gt; 1,4 0,0 -\u0026gt; 8,8 5,5 -\u0026gt; 8,2 You could visualize the map of the ocean floor as such:\n1.1....11. .111...2.. ..2.1.111. ...1.2.2.. .112313211 ...1.2.... ..1...1... .1.....1.. 1.......1. 222111.... Here, each . represents a coordinate where there are no vents, each 1 represents that there is one line of vents that occupies that coordinate, 2 represents that there are two lines of vents that occupy that coordinate, etc.\nThe goal is to calculate the overall number of coordinates of increased concern (i.e. spaces whose number is 2 or higher).\nMy First Solution # For starters, I parsed the input into a list of tuples of tuples, something like this:\ncoordinate_pairs =  [  {{0, 9}, {5, 9}},  {{8, 0}, {0, 8}},  # ... Next, I generated a list of lists to represent the ocean floor. I found the maximum x coordinate and maximum y coordinate in the input data, and generated the list of lists like so:\nocean_floor_map = List.duplicate(List.duplicate(0, max_x + 1), max_y + 1) Easy. Next, my idea was to perform a reduce where each pair of coordinates would be \u0026ldquo;applied\u0026rdquo; to the ocean_floor_map (details on that to come). Something like this:\nfinished_ocean_map = Enum.reduce(pairs, ocean_floor_map, \u0026amp;apply_pair/2) OK, simple. For the implementation of apply_pair/2, I used Elixir\u0026rsquo;s for macro—it\u0026rsquo;s list comprehension construct—to generate all coordinate pairs between the start coordinate and the end coordinate, and then used update_in/3 to increment the value at those locations. It looked like this:\ndef apply_pair(coordinate_pair, ocean_floor_map) do  case coordinate_pair do  {{x, y1}, {x, y2}} -\u0026gt;  Enum.reduce(y1..y2, ocean_floor_map, fn y, acc -\u0026gt;  update_in(acc, [Access.at(x), Access.at(y)], \u0026amp;(\u0026amp;1 + 1))  end)   {{x1, y}, {x2, y}} -\u0026gt;  Enum.reduce(x1..x2, ocean_floor_map, fn x, acc -\u0026gt;  update_in(acc, [Access.at(x), Access.at(y)], \u0026amp;(\u0026amp;1 + 1))  end)   {{x1, y1}, {x2, y2}} -\u0026gt;  Enum.reduce(Enum.zip(x1..x2, y1..y2), ocean_floor_map, fn {x, y}, acc -\u0026gt;  update_in(acc, [Access.at(x), Access.at(y)], \u0026amp;(\u0026amp;1 + 1))  end)  end end Once we have our finished_ocean_map, calculating the number or coordinates of concern was pretty simple:\nEnum.count(List.flatten(finished_ocean_map), \u0026amp;(\u0026amp;1 \u0026gt; 1)) Voila. Only one small problem: This solution is slow. For part one, the code only needed to consider horizontal or vertical lines of vents (i.e. not diagonal vent lines). On my laptop, this solution took nearly three seconds to run. Pretty slow. For part two, we consider all this lines. On my laptop, this solution took around 5.5 seconds—long enough for me to sit around twiddling my thumbs impatiently.\nImproving Performance # In order to figure out why my solution was so godawful slow, I used a built-in Elixir profiling tool, mix profile.eprof, to profile part one. There are several built-in profiling tools, but I chose eprof as it gives me both time consumed (in some unit and also as a fraction of the whole) and also number of calls. The output looked like this:\nProfile results of #PID\u0026lt;0.112.0\u0026gt; # CALLS % TIME µS/CALL Total 108705146 100.0 12921412 0.12 :gen_server.call/3 1 0.00 0 0.00 :erlang.list_to_tuple/1 1 0.00 0 0.00 :erlang.dt_spread_tag/1 1 0.00 0 0.00 ... :lists.do_flatten/2 983071 1.67 215602 0.22 :lists.reverse/2 207142 1.96 253151 1.22 Access.get_and_update_at/5 102804415 90.37 11677306 0.11 Profile done over 82 matching functions The output is truncated because it is long. Weirdly, in my opinion, eprof puts the function that consumes the most time at the bottom. In any case, that function turned out to be Access.get_and_update_at/5, using 90.37% of the total running time! Wow!\nMy old friend Access had betrayed me. The solution was too elegant, I thought, and I needed to resort to more limited List module functions. I changed the lines\nupdate_in(acc, [Access.at(y), Access.at(x)], \u0026amp;(\u0026amp;1 + 1)) to\nList.update_at(acc, y, fn row -\u0026gt; List.update_at(row, x, \u0026amp;(\u0026amp;1 + 1)) end) This does functionally the same thing, but is a bit more verbose. Let\u0026rsquo;s profile it!\nProfile results of #PID\u0026lt;0.112.0\u0026gt; # CALLS % TIME µS/CALL Total 107395276 100.0 21435654 0.20 :gen_server.call/3 1 0.00 0 0.00 :erlang.list_to_tuple/1 1 0.00 0 0.00 :erlang.dt_spread_tag/1 1 0.00 0 0.00 ... Enum.\u0026#34;-count/2-lists^foldl/2-0-\u0026#34;/3 981091 0.93 198430 0.20 :lists.do_flatten/2 983071 0.95 203816 0.21 List.do_update_at/3 102804415 96.23 20627578 0.20 Profile done over 78 matching functions This solution is managed to shave a couple hundred milliseconds off the runtime, but wasn\u0026rsquo;t the substantial gain I was looking for. Part two still took almost five seconds to run!\nIt was then that I realized that I had completely missed the point. In languages like C with \u0026ldquo;true\u0026rdquo; arrays and mutation, a solution resembling this one would be blazing fast. After all, finding the point we need to update in our matrix would be some trivial pointer arithmetic, followed by around three instructions to actually perform the update. Quick and easy. However, in Elixir, as with many other functional languages, we are working with immutable datastructures—meaning that we can\u0026rsquo;t update them, we can only make a copy resembling the first but with some differences.\nIn this case, if I was performing an operation such as update_in(acc, [Access.at(9), Access.at(5)], \u0026amp;(\u0026amp;1 + 1)), the runtime needs to create a new list for row 9, copying all values for each column except the value for column 5, which needs to be incremented. Since a row in the ocean floor map has been \u0026ldquo;modified,\u0026rdquo; the runtime also needs to create a whole new ocean floor map. If the runtime is clever, the other rows can be reused since they haven\u0026rsquo;t changed. Either way, this is obviously a lot more work than the efficient C-style solution.\nBut what if we changed our ocean_floor_map datastructure to something that handles updates more efficiently than a list of lists? Let\u0026rsquo;s try a Map, where the keys represent coordinates and the values are the number of vent lines intersection that spot (initialized to zero):\nocean_floor_map = for x \u0026lt;- 0..(max_x + 1), y \u0026lt;- (0..max_y + 1), into: %{}, do: {{x, y}, 0} Now that we\u0026rsquo;re using a Map for our ocean_floor_map, we\u0026rsquo;ll need to update our apply_pair function accordingly. For this, I changed instances of\nList.update_at(acc, y, fn row -\u0026gt; List.update_at(row, x, \u0026amp;(\u0026amp;1 + 1)) end) to\nMap.update!(acc, {x, y}, \u0026amp;(\u0026amp;1 + 1)) That\u0026rsquo;s actually pretty clean! Last bit, let\u0026rsquo;s update our counting code:\nEnum.count(finished_ocean_map, fn {_coordinate, vent_count} -\u0026gt; vent_count \u0026gt; 1 end) That\u0026rsquo;s pretty clean too! We were able to get rid of our List.flatten call.\nAlright, time to profile it:\nProfile results of #PID\u0026lt;0.112.0\u0026gt; # CALLS % TIME µS/CALL Total 7343728 100.0 224661 0.31 :gen_server.call/3 1 0.00 0 0.00 :erlang.list_to_tuple/1 1 0.00 0 0.00 :erlang.dt_spread_tag/1 1 0.00 0 0.00 ... anonymous fn/1 in Day5.apply_pair/2 48900 11.25 252832 5.17 :maps.fold_1/3 983073 13.20 296612 0.30 anonymous fn/3 in Day5.problem1/0 983072 14.51 325883 0.33 Profile done over 79 matching functions You may have noticed that updating the ocean floor map is no longer dominating our running time. Also, in practice this dropped the running time for part one and part two to 1.5 seconds 1.8 seconds, respectively. Not bad!\nI knew we could do even better, though. When I was writing this solution, I remembered that Map.update!/3 has a companion form, Map.update/4. The primary difference between these two is their behavior when the specified key does not exist in the map. In the former, a runtime error is raised. In the latter, the \u0026ldquo;default\u0026rdquo; argument will populated into the map as the value for the key instead of running the function argument. By switching from Map.update!/3 to Map.update/4, we could avoid storing data for coordinates where no vents exist! The less data we store, the faster updating copying will be.\nFirst, let\u0026rsquo;s simplify our ocean_floor_map initialization:\nocean_floor_map = %{} Love it! 💖\nAlright, and let\u0026rsquo;s update our Map.update!/3 to a Map.update/4:\nMap.update(acc, {x, y}, 1, \u0026amp;(\u0026amp;1 + 1)) Simple enough! And, finally, let\u0026rsquo;s profile it:\nProfile results of #PID\u0026lt;0.112.0\u0026gt; # CALLS % TIME µS/CALL Total 821805 100.0 24199 0.29 :gen_server.call/3 1 0.00 0 0.00 :erlang.list_to_tuple/1 1 0.00 0 0.00 :erlang.dt_spread_tag/1 1 0.00 0 0.00 ... anonymous fn/3 in Enum.count/2 97075 9.76 23614 0.24 :maps.fold_1/3 97076 14.82 35873 0.37 Map.update/4 103571 31.17 75427 0.73 Profile done over 58 matching functions This resulted in part one and part two completing in 0.63 seconds and 0.75 seconds, respectively. Seeing as the BEAM takes roughly 500 ms to launch on my laptop anyhow, I\u0026rsquo;m very satisfied with this performance.\nYou can find the finished code for the solution on GitHub.\nI hope you enjoyed taking this adventure with me, and happy hacking!\n","date":"December 5, 2021","permalink":"/posts/2021-12-05-profiling-elixir-for-advent-of-code/","section":"Posts","summary":"Every now and again, you may run into a problem that isn\u0026rsquo;t hard to solve using functional programming, but which is hard to solve quickly using functional programming. For me, today, that problem was Advent of Code, Day 5.\nIf you\u0026rsquo;re participating in Advent of Code and you haven\u0026rsquo;t yet solved Day 5, this is your last chance to leave the page without spoilers. You have been warned!\nThe Problem # You are provided with a list of lines of hydrothermal vents on the ocean floor.","title":"Profiling Elixir for Advent of Code"},{"content":"","date":"October 30, 2021","permalink":"/tags/haskell/","section":"Tags","summary":"","title":"haskell"},{"content":"","date":"October 30, 2021","permalink":"/tags/logic-programming/","section":"Tags","summary":"","title":"logic programming"},{"content":"","date":"October 30, 2021","permalink":"/tags/prolog/","section":"Tags","summary":"","title":"prolog"},{"content":"While reading through Miran Lipovača\u0026rsquo;s excellent Learn You a Haskell, I came across the following problem:\n Which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24?\n To demonstrate some properties of different programming languages, I\u0026rsquo;ll solve this problem in three languages embodying three different paradigms:\n C (imperative and procedural) Haskell (functional) Prolog (logic and constraint)  C # The general approach I\u0026rsquo;ll be taking here is to generate every set of possible lengths fitting the constraints (namely being integers between 1 and 10) and then check to see if the other two conditions are met (being a right triangle, having a perimeter of 24).\nLet\u0026rsquo;s start with the side-length piece1:\nvoid right_triangle() {  int a, b, c;   for (c = 1; c \u0026lt;= 10; c++) {  for (b = 1; b \u0026lt;= 10; b++) {  for (a = 1; a \u0026lt;= 10; a++) {  # TODO: Perform perimeter and right triangle checks  printf(\u0026#34;[%i, %i, %i]\\n\u0026#34;, a, b, c);  }  }  } } Running this code shows not only every possible set of sides, but every possible permutation of every possible set of side lengths! That\u0026rsquo;s a bit much. Let\u0026rsquo;s decide that c is the hypotenuse, b is the next longest side, and a is that last side that is at most equal in length to b. These constraints also reduce our search space, making the code run faster!\nvoid right_triangle() {  int a, b, c;   for (c = 1; c \u0026lt;= 10; c++) {  for (b = 1; b \u0026lt; c; b++) {  for (a = 1; a \u0026lt;= b; a++) {  # TODO: Perform perimeter and right triangle checks  printf(\u0026#34;[%i, %i, %i]\\n\u0026#34;, a, b, c);  }  }  } } OK, great. Now let\u0026rsquo;s check our perimeter and right triangle constraints. The former is simply a matter of adding up the side lengths, nothing special there. For checking that our side lengths create a right triangle, Pythagorus tells us that, given that the hypotenuse of a triangle is represented by \u0026ldquo;c\u0026rdquo; and the other two sides by \u0026ldquo;a\u0026rdquo; and \u0026ldquo;b\u0026rdquo;, the side lengths must follow the rule a² + b² = c².\nLet\u0026rsquo;s add those checks:\nvoid right_triangle() {  int a, b, c;   for (c = 1; c \u0026lt;= 10; c++) {  for (b = 1; b \u0026lt;= c; b++) {  for (a = 1; a \u0026lt;= b; a++) {  if (a + b + c == 24 \u0026amp;\u0026amp; pow(a, 2) + pow(b, 2) == pow(c, 2)) {  printf(\u0026#34;[%i, %i, %i]\\n\u0026#34;, a, b, c);  }  }  }  } } That\u0026rsquo;s it! When we call this function, the solution to the problem ([6, 8, 10]) is printed to the console.\nTry it for yourself!\n Haskell # In Haskell, the most analogous way to solve this problem is via a \u0026ldquo;list comprehension\u0026rdquo;. This construct exists in other languages, and often looks quite similar2.\nLet\u0026rsquo;s break down how list comprehensions work. They have three parts:\n Generator(s) Filter(s) Mapper  Generators # Let\u0026rsquo;s start with the generators. Using our optimization from the C solution, our first generator is c \u0026lt;- [1..10], which will give the binding c each value between 1 and 10, followed by b \u0026lt;- [1..c], which will give b each value between 1 and c, and ending with a \u0026lt;- [1..b], which will give a each value between 1 and b.\nThe comprehension with only our generators (and technically also a mapper, but we\u0026rsquo;ll get to that in a moment) looks like this:\n\u0026gt; [(a, b, c) | c \u0026lt;- [1..10], b \u0026lt;- [1..c], a \u0026lt;- [1..b]] [(1,1,1),(1,1,2),(1,2,2),(2,2,2),(1,1,3),(1,2,3),(2,2,3),(1,3,3) ... (the result is very long, and has been truncated)\nSee for yourself!\n Filters # Now we need to filter out all sets of sides that don\u0026rsquo;t form a right triangle or don\u0026rsquo;t sum to 24. Filters go after generators (though I think the two can be interspersed), and are simply boolean expressions. For instance, the perimeter filter is the boolean expression a + b + c == 24 and the right triangle filter is the boolean expression a^2 + b^2 == c^2.3\nThis gives us:\n\u0026gt; [(a, b, c) | c \u0026lt;- [1..10], b \u0026lt;- [1..c], a \u0026lt;- [1..b], a + b + c == 24, a^2 + b^2 == c^2] [(6,8,10)] There\u0026rsquo;s our solution! Try it!\n Mappers # But wait, there\u0026rsquo;s more! Did you notice the (a, b, c) bit at the beginning of each comprehension? What happens if we changed that to something different?\n\u0026gt; [(a * b) / 2 | c \u0026lt;- [1..10], b \u0026lt;- [1..c], a \u0026lt;- [1..b], a + b + c == 24, a^2 + b^2 == c^2] [24.0] I changed the expression (a, b, c) to the expression (a * b) / 2, which gives us the area of the triangle instead of a tuple of the lengths of its sides. But why call it a mapper? Well, that\u0026rsquo;s because each set of generated values that make it past the filters are given to the mapper to be turned into some kind of final result. In the case of this problem, there\u0026rsquo;s only one set of values that make it past the filters (c being 10, b being 8, and a being 6) and so only that one set of values gets \u0026ldquo;mapped\u0026rdquo;.\nSee for yourself!\n Prolog # The Prolog solution that we\u0026rsquo;ll write will be profoundly different from the previous two. While the Haskell syntax is far more concise and expressive than the C syntax, the solutions in both languages follow essentially the same two steps:\n Generate all possible combinations of side lengths Check each set of side lengths to see if it\u0026rsquo;s the solution.  However, Prolog doesn\u0026rsquo;t have the facilities to do these things, at least not in the same way. A Prolog program consists of two elements: facts and rules.\nFacts # Facts are exactly what they sound like. For instance, the following fact states that mike is a parent of john:\nparent(mike, john). The term parent in the fact above is referred to as a \u0026ldquo;relation\u0026rdquo; because it describes the relationship between mike and john.\nHaving defined a fact, we can ask Prolog about it4:\n?- parent(mike, john). true. ?- parent(A, john). A = mike. (?- is the Prolog REPL prompt, where you can make queries)\nProlog can tell us if a statement is true, or how we might make it true. Nifty!\nHere, try it for yourself!\n Rules # Rules represent ways in which we can extend our existing facts or rules to derive more information. For instance, below is an ancestor rule that builds upon our parent relation. It can tell us if A is an ancestor of B:\nancestor(A, B) :-  parent(A, B);  parent(C, B), ancestor(A, C). In Prolog, ; is read as \u0026ldquo;or\u0026rdquo; and , is read as \u0026ldquo;and\u0026rdquo;, making the above rule:\n A is an ancestor of B if A is the parent of B or if C is the parent of B and A is an ancestor of C.\n Try it! When Prolog returns a result but doesn\u0026rsquo;t create a new prompt, this indicates that there may be more than one result, and Prolog wants you to tell it whether you want it to try to find the next answer or stop. To tell Prolog to try to find another solution, type ;. To tell Prolog to stop searching for solutions, type ..\n Back to Triangles # Interesting! But what does this all this have to do with triangles? Well, nothing, other than that relations can also be used to express constraints (since 1982\u0026rsquo;s Prolog II). For instance, the following line states that A must be between 1 and 10 (inclusive):\n?- between(1, 10, A). A = 1 ; A = 2 ; A = 3 ; A = 4 ; A = 5 ; A = 6 ; A = 7 ; A = 8 ; A = 9 ; A = 10. Note that I didn\u0026rsquo;t have to define between/3, it is built-in to Prolog.\nIn fact, we can phrase our entire problem as a set of constraints on the triangle\u0026rsquo;s sides!\n The lengths of the three sides must be between 1 and 10. The perimeter of the triangle (the sum of the sides) must equal 24. The sides must form a right triangle.  Therefore, our complete Prolog solution is this:\nsolution(A, B, C) :-  between(1, 10, C), between(1, C, B), between(1, B, A),  A + B + C =:= 24,  A^2 + B^2 =:= C^2. (Note that I also included our additional constraints on A and B to preclude permutations here.)\nQueried like so:\n?- solution(A, B, C). A = 6, B = 8, C = 10 Try it!\n Now, you\u0026rsquo;ve probably noticed something strange about some of these rules: Namely, that I used =:= instead of = whenever I had to do math. This is just part of the way Prolog is; the =:= operator \u0026ldquo;evals\u0026rdquo; each of it\u0026rsquo;s arguments (the left and righthand sides) to determine if the solution has been found, whereas =, the unification operator, does not evaluate it\u0026rsquo;s arguments; it only succeeds if they are the same. Thus when prompted with A + B + C = 24, the Prolog interpreter doesn\u0026rsquo;t care what A, B, or C are; it can clearly tell that the left side is an expression and the right side is an integer, those are not the same, and the unification is a failure.\nIt\u0026rsquo;s pretty odd and will really stretch your brain the more you think about it.\nConclusions # Of the above three, I\u0026rsquo;m particularly fond of the Prolog solution despite it\u0026rsquo;s weird math limitations. \u0026ldquo;Why?\u0026rdquo; you ask? Well, because the Prolog solution is the most declarative. Ward Cunningham defines declarative programming as the following:\n Programming where problems are described, or conditions on a solution are described, and the computer finds a solution.\n In the Prolog solution, as opposed to the C and Haskell solutions, I was not required to give any information about how to go about solving this problem; Prolog was able to do that on it\u0026rsquo;s own. Heck, it may have created 220 threads to check each possible combination of side lengths simultaneously or it may have just tried numbers at random; it\u0026rsquo;s really no concern of mine. And I love that.\nHowever, Prolog, as we\u0026rsquo;ve seen, isn\u0026rsquo;t the most practical or pretty language. While it was well-suited to the problem that I addressed here, it is not well-suited to every problem, perhaps not even a majority of problems. Additionally, Prolog intends to be a standalone programming language and most distributions (such as SWI-Prolog or GNU Prolog) include rules for performing side-effects (such as writing to the console), which don\u0026rsquo;t really make sense in logic or constraint programming.\nWith that said, there is a promising new trend of logic and constraint DSLs that can be used within functional or imperative languages, such as miniKanren and Datalog. Introducing these paradigms inside of existing languages (which commonly already feature DSLs for purposes such as building regular expressions or constructing SQL queries) allows developers to reach for them when they provide the most elegant solution and ignore them otherwise. This, I feel, is the future for logic and constraint languages, and I personally can\u0026rsquo;t wait!\n  While I declared my variables at the top of my function, I think modern C allows for you to write variable declarations inline in for loops (e.g. for (int c = 1; ...). I\u0026rsquo;m old-fashioned though.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Equivalent solution in Erlang:\nright_triangles() -\u0026gt;  [{A, B, C} || C \u0026lt;- lists:seq(1, 10), B \u0026lt;- lists:seq(1, C), A \u0026lt;- lists:seq(1, B), math:pow(A, 2) + math:pow(B, 2) == math:pow(C, 2), A + B + C == 24]. The Erlang syntax is much more verbose, but fundamentally we\u0026rsquo;ve only traded (a, b, c) for {A, B, C}, | for ||, [a..b] for lists:seq(A, B), and a^b for math:pow(A, B).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ^ is the exponentiation operator in Haskell\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n In Prolog, terms starting with a lowercase letter are atoms and terms starting with an uppercase letter are variables.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"October 30, 2021","permalink":"/posts/2021-10-30-truly-declarative-logic-programming/","section":"Posts","summary":"While reading through Miran Lipovača\u0026rsquo;s excellent Learn You a Haskell, I came across the following problem:\n Which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24?\n To demonstrate some properties of different programming languages, I\u0026rsquo;ll solve this problem in three languages embodying three different paradigms:\n C (imperative and procedural) Haskell (functional) Prolog (logic and constraint)  C # The general approach I\u0026rsquo;ll be taking here is to generate every set of possible lengths fitting the constraints (namely being integers between 1 and 10) and then check to see if the other two conditions are met (being a right triangle, having a perimeter of 24).","title":"Truly Declarative: Logic Programming"},{"content":"As developers begin learning Elixir, they often have a very understandable confusion around the difference between Elixir\u0026rsquo;s behaviours and protocols. These are similar constructs, but with important differences.\nBehaviours # Behaviours are conceptually quite simple:\n A behaviour module defines a set of functions and macros (referred to as callbacks) that callback modules implementing that behaviour must export.\n For instance, a commonly used behaviour is GenServer, used like so:\ndefmodule MyApp.APICache do  @behaviour GenServer end However, this module fails to compile with the following error:\nwarning: function init/1 required by behaviour GenServer is not implemented (in module MyApp.APICache) In other words, the GenServer behaviour specified that modules implementing it must define an init/1 function that starts the GenServer process. By enforcing the existence of an init/1 function, the GenServer behaviour ensures that if a module knows how to start one implementation of GenServer, it knows how to start all implementations of GenServer.\nThis demonstrates the central proposition of behaviours: behaviours allow modules to be interchangeable.\nThis property of interchangeability lends itself to use with the Dispatcher Pattern. Let\u0026rsquo;s say that we are writing an application that takes the name of a product and tries to find a price for that item on an online marketplace. We could write our application like so:\ndefmodule PriceFinder do  @spec product_price(String.t()) :: integer  def product_price(product_name) do  cond do  is_boat?(product_name) -\u0026gt;  BoatTraderAPI.find_boat_price(product_name)   is_computer_component?(product_name) -\u0026gt;  NeweggAPI.find_component_price(product_name)   is_car?(product_name) -\u0026gt;  JoydriveAPI.find_car_price(product_name)  end  end   # ... This is fine, but consider the case where a developer makes a small change such that BoatTraderAPI.find_boat_price/1 now returns a float instead of an integer. Whoops! Sadly, this is the kind of error that Dialyzer isn\u0026rsquo;t likely to catch1. To remedy this, a well-meaning developer might make the following change:\n- BoatTraderAPI.find_boat_price(product_name) + float_price = BoatTraderAPI.find_boat_price(product_name) + floor(float_price * 100) However, now our product_price/1 function has started to bloat with BoatTrader-specific logic.\nSo, what\u0026rsquo;s the alternative? Let\u0026rsquo;s write a behaviour and a dispatcher.\ndefmodule PriceFinder do  @callback product_price(String.t()) :: integer   @spec product_price(String.t()) :: integer  def product_price(product_name) do  implementation(product_name).product_price(product_name)  end   defp implementation(product_name) do  cond do  is_boat?(product_name) -\u0026gt; BoatTraderAPI  is_computer_component?(product_name) -\u0026gt; NeweggAPI  is_car?(product_name) -\u0026gt; JoydriveAPI  end  end   # ... 2\nIn this case, BoatTraderAPI, NeweggAPI, and JoydriveAPI (collectively, the implementations) should all contain @behaviour PriceFinder. This way, PriceFinder.product_price/1 (the dispatcher) can be assured that a product_price/1 function exists within each of those modules, and Dialyzer can check that the implementations conform to the typespec specified. Consequently, type-related errors should be harder to introduce and the dispatcher leaves no room for vendor-specific bloat to creep in.\nProtocols # Given what we now know about behaviours, the documentation\u0026rsquo;s summary of protocols is somewhat confusing:\n A protocol specifies an API that should be defined by its implementations. A protocol is defined with Kernel.defprotocol/2 and its implementations with Kernel.defimpl/3.\n This sounds exactly like what behaviours are for, and indeed, protocols use behaviours under-the-hood. However, where protocols and behaviours differ is with a constraint that the summary did not specify. Namely, that each implementation of a protocol must be for a distinct data type.\nTo understand this further, let\u0026rsquo;s take a look at a protocol in the Elixir standard library: String.Chars. While this may sound unfamiliar to you, you have certainly used it before as Kernel.to_string/1:\ndefmacro to_string(term) do  quote(do: :\u0026#34;Elixir.String.Chars\u0026#34;.to_string(unquote(term))) end This strange-looking macro is simply transforming your to_string(my_string) call to String.Chars.to_string(my_string) at compile-time. String.Chars.to_string/1 (and Kernel.to_string/1, by virtue of this macro expansion) can take any of a wide variety of data types and return a string representation of them.\nAlright, so how then is String.Chars.to_string/1 defined? This is the entirety of the String.Chars module with the documentation removed for brevity:\ndefprotocol String.Chars do  @spec to_string(t) :: String.t()  def to_string(term) end However, just below that protocol\u0026rsquo;s definition in string/chars.ex are the implementations for many of Elixir\u0026rsquo;s datatypes. Here are implementations for Integer and Float:\ndefimpl String.Chars, for: Integer do  def to_string(term) do  Integer.to_string(term)  end end  defimpl String.Chars, for: Float do  def to_string(term) do  IO.iodata_to_binary(:io_lib_format.fwrite_g(term))  end end As you can see, inside each defimpl String.Chars, for: ... there must be a to_string/1 function defined that transforms its given datatype (here, either Integer or Float) to a string. When String.Chars.to_string/1 is called, it will effectively look at the type of the argument it was passed and call the corresponding implementation.\nA single function that has differing implementations based on which data type is passed is said to exhibit ad-hoc polymorphism. This is commonly contrasted with parametric polymorphism, where a function can handle different data types but the implementation is the same for all (consider that the single implementation of Enum.map/2 can handle lists of integers, lists of strings, etc).\nWhat\u0026rsquo;s even more interesting, though, is that each Elixir struct is considered it\u0026rsquo;s own \u0026ldquo;type\u0026rdquo; for the purposes of protocols. For fun, let\u0026rsquo;s define our own type:\ndefmodule Boat do  defstruct [:length, :fuel_type] end Alright, and let\u0026rsquo;s try to stringify an instance of this new struct:\nto_string(%Boat{length: 41, fuel_type: \u0026#34;diesel\u0026#34;}) #=\u0026gt; ** (Protocol.UndefinedError) protocol String.Chars not implemented for #=\u0026gt; %Boat{fuel_type: \u0026#34;diesel\u0026#34;, length: 41} of type Boat (a struct) If we want our Boat \u0026ldquo;type\u0026rdquo; to have a string representation, we\u0026rsquo;ll have to implement the String.Chars protocol!\ndefimpl String.Chars, for: Boat do  def to_string(boat),  do: \u0026#34;A #{boat.length}\u0026#39; boat powered by #{boat.fuel_type}\u0026#34; end to_string(%Boat{length: 41, fuel_type: \u0026#34;diesel\u0026#34;}) #=\u0026gt; \u0026#34;A 41\u0026#39; boat powered by diesel\u0026#34; This has also exposed another power of protocols: a protocol can dispatch to a module that is not known to it. For instance, the authors of the String.Chars protocol had no idea that I would come along and implement their protocol for my Boat struct. And they didn\u0026rsquo;t have to! Protocols essentially implement the implementation/1 function we defined in the behaviour example above by dispatching solely by the type of the argument, and the dispatcher is automatically extended to any new implementations.\nThe popular Jason library uses this concept with its Jason.Encoder protocol. You can implement the Jason.Encoder protocol on your structs to tell Jason how to JSON-encode them.\nAlright, let\u0026rsquo;s tie what we\u0026rsquo;ve now learned about protocols together with our example from earlier, but with a slight twist. Instead of the user providing us the name of a product, they will choose a product from our collection of Boats, Components, and Cars (where Boat, Component, and Car are structs).\nModifying our behaviour-based solution from earlier to fit this new model yields the following:\ndefmodule PriceFinder do  @callback product_price(any) :: integer   @spec product_price(any) :: integer  def product_price(product) do  implementation(product).product_price(product)  end   defp implementation(product) do  cond do  is_struct(product, Boat) -\u0026gt; BoatTraderAPI  is_struct(product, Component) -\u0026gt; NeweggAPI  is_struct(product, Car) -\u0026gt; JoydriveAPI  end  end end Not bad! However, now that our implementation/1 function is based solely around \u0026ldquo;types\u0026rdquo;, we can use a protocol instead!3\ndefprotocol PriceFinder do  @spec product_price(t) :: integer  def product_price(product) end  defimpl PriceFinder, for: Boat do  def product_price(boat), do: BoatTraderAPI.product_price(boat) end  defimpl PriceFinder, for: Component do  def product_price(component), do: NeweggAPI.product_price(component) end  defimpl PriceFinder, for: Car do  def product_price(car), do: JoydriveAPI.product_price(car) end If our PriceFinder module is going to be shipped as part of a library, the protocol approach would allow users of the library to implement the PriceFinder protocol for their own structs. So long as there exists a defimpl of the PriceFinder protocol for the type (or struct) being passed, calling PriceFinder.product_price will find the appropriate implementation and invoke it.\nConclusion # In short, both behaviours and protocols define an interface which must be fulfilled by its implementations. Behaviours are more general-purpose than protocols, and are sometimes used with dispatchers. Protocols are built on top of behaviours and have a type-based dispatcher built-in—one that is extensible to external types as well.\n  Dialyzer only reports issues with typespecs that will never be met. Since our product_price/1 function can sometimes comply with its typespec when the find_boat_price function has the wrong return type (namely the find_component_price and find_car_price functions and corresponding cond arms will still return the correct type), Dialyzer will ignore the potential discrepancy.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Did you notice the duplicated typespec between @callback and @spec? Sadly, that is necessary due to another weakness of Dialyzer. Each of our implementations must comply with the @callback typing, which means Dialyzer should be able to infer the success typing of product_price/1 to be the same. However, Dialyzer sees the return type of product_price/1 as being the return type of apply(module, :product_price, [String.t()]). Dialyzer will not visit each module to see what its product_price/1 return type is—or even if some product_price/1 function even exists! It simply knows that the return type of apply/3 is any and bubbles that result up to the product_price/1 function. Therefore, we must provide a meaningful return type for product_price/1 such that Dialyzer may check the places where product_price/1 is called.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Notice the @spec in the protocol definition? Not only does that apply to the generated PriceFinder.product_price/1 function, but it will also be applied to each implementation as well.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"October 14, 2021","permalink":"/posts/2021-10-14-elixir-behaviours-vs-protocols/","section":"Posts","summary":"As developers begin learning Elixir, they often have a very understandable confusion around the difference between Elixir\u0026rsquo;s behaviours and protocols. These are similar constructs, but with important differences.\nBehaviours # Behaviours are conceptually quite simple:\n A behaviour module defines a set of functions and macros (referred to as callbacks) that callback modules implementing that behaviour must export.\n For instance, a commonly used behaviour is GenServer, used like so:","title":"Elixir Behaviours vs Protocols"},{"content":"José recently announced the availability of Elixir 1.12.0 rc.0, a precursor to the full Elixir 1.12.0 release which should come within the next month or so. This update consists primarily of developer quality-of-life improvements. In his announcement, José elaborated on a few changes, but I couldn\u0026rsquo;t help but feel that some exciting changes were relegated to footnotes. As such, I\u0026rsquo;m dedicating this post to trawling through the full changelog and shining a spotlight on a few of my favorite changes.\nMix.install # Let\u0026rsquo;s say that there\u0026rsquo;s a cool new Elixir library that you\u0026rsquo;d like to try out. In previous Elixir versions, experimenting with a new library would require you to create a new Mix project, add the library as a dependency, and start an IEx shell in the project (iex -S mix). Well, dabblers rejoice! A recent PR by Wojtek Mach adds the ability for one to install an arbitrary package from Hex inside an IEx shell by running Mix.install/1.\nInteractive Elixir (1.12.0-rc.0) - press Ctrl+C to exit (type h() ENTER for help) iex(1)\u0026gt; Mix.install([:finch]) :ok iex(2)\u0026gt; Finch.start_link(name: MyFinch) {:ok, #PID\u0026lt;0.223.0\u0026gt;} In this example, I opened a new IEx shell outside of any project, and used Mix.install to pull in the Finch HTTP library that there\u0026rsquo;s been much hubbub about lately. This feature is so convenient, I have a feeling I\u0026rsquo;ll be doing this a whole lot going forward!\nInteger.pow/2 and Float.pow/2 # This may strike you as surprising, but Elixir has no ** exponentiation operator and, until version 1.12, no pow function. Previously, developers who needed to use exponents were directed to use Erlang\u0026rsquo;s math:pow/2. Well, fret not, pow-er users!\niex(1)\u0026gt; Integer.pow(2, 3) 8 The Integer.pow/2 function requires both the base and the exponent to be integers. If you have a float that you need to raise to an exponent, Float.pow/2 is the function for you.\niex(1)\u0026gt; Float.pow(2.0, 0.5) 1.4142135623730951 Under-the-hood, Integer.pow/2 uses an exponentiation by squaring approach whereas Float.pow/2 simply calls Erlang\u0026rsquo;s math:pow/2. Beware, neither of these function supports raising an integer to a float power (e.g. Float.pow(2, 0.5)). For that edge-case, you\u0026rsquo;ll either need to cast your integer base to a float or call Erlang\u0026rsquo;s more lenient math:pow/2.\nStepped Ranges # Elixir has had ranges for quite some time written in the form first..last. Elixir will determine whether the step between the numbers should be either 1 or -1 by comparing the \u0026ldquo;first\u0026rdquo; and \u0026ldquo;last\u0026rdquo; numbers.\niex(1)\u0026gt; Enum.to_list(1..10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  iex(2)\u0026gt; Enum.to_list(10..1) [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] José pointed out three limitation with ranges in his proposal on the mailing list:\n It is not possible to have ranges with custom steps It is not possible to have empty ranges Users may accidentally forget to check the range boundaries  His first concern is very clear and the last is referring to pattern-matching on ranges which I have never actually seen in production. However, I found his second listed limitation pretty intriguing, so I tried to create an empty range:\niex(1)\u0026gt; Enum.to_list(1..1) [1]  iex(2)\u0026gt; Enum.to_list(1..0) [1, 0] Sure enough, no dice.\nThe exact syntax for this feature was hotly debated on the mailing list, but was ultimately decided to be first..last//step, where step is optional if it is 1 or -1. An inferred step of -1 will be deprecated in future versions, though.\niex(1)\u0026gt; 1..10 1..10  iex(2)\u0026gt; 1..10//2 1..10//2  iex(3)\u0026gt; Enum.to_list(1..10//2) [1, 3, 5, 7, 9]  iex(4)\u0026gt; 10..1 10..1//-1  iex(5)\u0026gt; Enum.to_list(10..1) [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]  iex(6)\u0026gt; Enum.to_list(1..0//1) [] As you can see from the last example, Elixir\u0026rsquo;s ranges can now represent an empty range if the step does not agree with the direction from first to last. I imagine that this will provide an elegant solution to some annoying bugs.\nNotably, this feature was also applied to dates as Date.range/3 without new syntax. If you want every-other day in January 2021, you can now write the following:\niex(1)\u0026gt; Date.range(~D[2020-01-01], ~D[2020-01-31], 2) #DateRange\u0026lt;~D[2020-01-01], ~D[2020-01-31], 2\u0026gt; Kernel.then/2 # This feature was relegated to a footnote (alongside Integer.pow/2), but I think it warrants better. I had initially assumed that then/2 was for handling error types in a pipe, something like Brex.Result, but I was way off-base. then/2 simply allows you to pipe a value into an anonymous function.\niex(1)\u0026gt; 1 |\u0026gt; then(\u0026amp;(\u0026amp;1 * 2)) 2 If you thought that piping values into anonymous functions was something that Elixir could already do, you\u0026rsquo;d be technically correct. The syntax is pretty gnarly, though, since the invocation of an anonymous function is performed as fun.() (notice the .). Therefore, you had to wrap your anonymous function in an invocation:\niex(1)\u0026gt; 1 |\u0026gt; (\u0026amp;(\u0026amp;1 * 2)).() 2 See those parentheses surrounding the anonymous function? Yeah, those are mandatory. If you\u0026rsquo;re like me, you prefer the cleanliness of then/2.\nKernel.tap/2 # tap/2 has a strong resemblance to then/2, but with a key difference: the value created by the anonymous function given to tap/2 is discarded.\niex(1)\u0026gt; 1 |\u0026gt; tap(\u0026amp;IO.puts(\u0026amp;1)) |\u0026gt; then(\u0026amp;(\u0026amp;1 * 2)) 1 2 You may know that IO.puts/1 returns :ok, but that fact largely irrelevant here since that :ok is discarded, and the original value given to tap/2 (here, 1) is passed out unchanged.\nJust like Ruby\u0026rsquo;s tap method, which was almost assuredly the inspiration for this feature, the value of tap/2 lies in performing some IO with the value in the pipe chain. For instance, if you\u0026rsquo;re interested at what the value being passed through a pipe chain is at a given point, you can simply inject |\u0026gt; tap(\u0026amp;IO.puts(\u0026amp;1)) (as in the above example).\nFormatter will not add newlines around interpolation # This is very small, but has driven me crazy for a while now. Given a long string with interpolation, for example:\n\u0026#34;cannot build datetime with #{inspect(date)}and #{inspect(time)}, reason: #{inspect(reason)}\u0026#34; (this example comes from Elixir\u0026rsquo;s DateTime.new!/4)\nThe Elixir formatter in versions \u0026lt; 1.12 will format this line as:\n\u0026#34;cannot build datetime with #{inspect(date)}and #{inspect(time)}, reason: #{  inspect(reason) }\u0026#34; I think this looks just terrible. The good news for me is that as of Elixir 1.12, the formatter will now leave that line as-is!\nIEx learns about pipes # At some point you\u0026rsquo;ve probably tried to copy-and-paste a pipe chain from your application into an IEx console and encountered this error:\niex(1)\u0026gt; Post Post iex(2)\u0026gt; |\u0026gt; where([p], p.title == \u0026#34;Exciting Changes Coming in Elixir 1.12\u0026#34;) ** (SyntaxError) iex:4:1: syntax error before: \u0026#39;|\u0026gt;\u0026#39; Well, no longer! As of Elixir 1.12, IEx will now handle pipes!\niex(1)\u0026gt; Post Post iex(2)\u0026gt; |\u0026gt; where([p], p.title == \u0026#34;Exciting Changes Coming in Elixir 1.12\u0026#34;) #Ecto.Query\u0026lt;from p0 in MyApp.Post, where: p0.title == \u0026#34;Exciting Changes Coming in Elixir 1.12\u0026#34;\u0026gt; iex(3)\u0026gt; |\u0026gt; Repo.all() [] Conclusion # As you\u0026rsquo;ve probably deduced, there\u0026rsquo;s a lot to love about Elixir 1.12. It\u0026rsquo;s worth noting that while I covered quite a few things here, there is still far more that I didn\u0026rsquo;t which you can find in the announcement. I don\u0026rsquo;t know about you, but I\u0026rsquo;m quite excited for the full Elixir 1.12 release!\n","date":"April 14, 2021","permalink":"/posts/2021-04-14-elixir-1.12/","section":"Posts","summary":"José recently announced the availability of Elixir 1.12.0 rc.0, a precursor to the full Elixir 1.12.0 release which should come within the next month or so. This update consists primarily of developer quality-of-life improvements. In his announcement, José elaborated on a few changes, but I couldn\u0026rsquo;t help but feel that some exciting changes were relegated to footnotes. As such, I\u0026rsquo;m dedicating this post to trawling through the full changelog and shining a spotlight on a few of my favorite changes.","title":"Exciting Changes Coming in Elixir 1.12"},{"content":"","date":"March 6, 2021","permalink":"/tags/agile/","section":"Tags","summary":"","title":"agile"},{"content":"Writing a criticism of Agile after the word \u0026ldquo;Agile\u0026rdquo; has been pronounced dead by one of its authors may seem like overkill, but nothing has put a stop to the software industry\u0026rsquo;s glut of Agile certifications, occupations of \u0026ldquo;doing Agile\u0026rdquo;, and every engineering manager I\u0026rsquo;ve ever spoken to saying \u0026ldquo;Oh, yes, we do Agile here.\u0026rdquo; I could write an entire blog post haranguing the profiteering and narcissistic industry (see Dave Thomas\u0026rsquo; post linked above), but today I want to dive deeper, take a hard look at the original document, and ask \u0026ldquo;Who actually does this?\u0026rdquo;\n   The Agile Manifesto consists of four sets of values and twelve principles. The four values are:\n Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan  In particular, I want to take a close look at the third and fourth points.\nCustomer Collaboration # If you are a software developer, I want you to ask yourself the following question:\n When was the last time you spoke to a customer?\n I\u0026rsquo;m willing to bet that if your company\u0026rsquo;s industry doesn\u0026rsquo;t contain the word \u0026ldquo;software,\u0026rdquo; your answer is \u0026ldquo;Never.\u0026rdquo; If you work in software consulting or for a B2C software company, your answer is hopefully \u0026ldquo;recently,\u0026rdquo; and you can feel free to stop reading at this point. But for those of us who work on development teams in industries such as finance, healthcare, or telecom the very idea of \u0026ldquo;customer collaboration\u0026rdquo; seems alien.\nWhy is that? I would suggest that the answer lies in looking to the right: \u0026ldquo;contract negotiation.\u0026rdquo; The only contract that I\u0026rsquo;ve negotiated as a software developer is that of my own employment—contracts between my company and customers have always been handled by someone \u0026ldquo;above\u0026rdquo; me, whether an engineering manager or even a dedicated sales team. The first I hear of a customer need is when I\u0026rsquo;m assigned to an epic that outlines all of the aspects of a feature that my company is contractually obligated to build within a set timeframe.\nTo a large degree, this is an artifact of the industry. For instance, the lawyers for a pharmacy chain aren\u0026rsquo;t going to be pleased if your company\u0026rsquo;s approach to building software is \u0026ldquo;The software will be finished when it\u0026rsquo;s finished.\u0026rdquo; This sentiment is an insult to the very way that company does business! In most industries, when two companies decide to work together they begin with a written contract. In order to protect their investment, the company purchasing services has an interest in outlining concrete units of work that must be completed within set periods of time. If they feel that the vendor they hired is underperforming, they can prove this by referencing the contract and will be legally protected when seeking to terminate the contract or refund their purchase.\nBy the time the project begins, and the third Agile value has already been eshewed.\nResponding to Change # \u0026ldquo;Customer collaboration\u0026rdquo; and \u0026ldquo;Responding to change\u0026rdquo; are tightly related concepts. After all, don\u0026rsquo;t most of the changes you make to your software come from your customers? Despite not being involved in contract negotiation, perhaps a software developer could deliver some working software quickly, receive some feedback, and respond. However, that\u0026rsquo;s rarely the case.\nSee if this sounds familiar to you: I typically spend about a week developing the first draft of a feature. However, I don\u0026rsquo;t have direct contact with the customer to ask if it meets their expectations, so I\u0026rsquo;ll notify my manager that the first draft is ready for the customer to review. My manager will then tell the customer representative, the customer representative will enlist a potential user to try the new feature, that person will provide feedback back to the customer representative, the customer representative will provide that feedback to my manager, and my manager will provide the feedback to me. This process takes weeks. I can\u0026rsquo;t just sit on my hands while all of this takes place, I\u0026rsquo;ve got to keep working! So by the time that I receive feedback on my work, the feature is already finished or nearly so. If the feedback I ultimately receive is \u0026ldquo;The customer has determined that this feature isn\u0026rsquo;t actually useful after all,\u0026rdquo; or \u0026ldquo;The customer thinks that the feature would be more useful if it was completely restructured,\u0026rdquo; weeks worth of my effort have been wasted.\n   In order for developers to truly utilize the Agile approach, they must have direct contact with their customers.\nAt this point, let\u0026rsquo;s take a step back and ask: Why don\u0026rsquo;t developers have direct contact with customers?\nOne theory is simply that non-software industries—automotive, manufacturing, etc—have been doing business long before software came on the scene, and are not prepared to let seventeen unelected programmers tell them how to run their businesses. Long before software, these companies were selling products using dedicated sales teams and managing clients with account managers. Agile methodologies may have revolutionized the software industry, but they didn\u0026rsquo;t revolutionize banking.\nAnother theory is that companies worry about their developer\u0026rsquo;s communication skills—and for good reason! In order for developers to engage in \u0026ldquo;customer collaboration,\u0026rdquo; developers need to be able to communicate clearly with their non-technical counterparts. The trope of a developer blurting a string of barely coherent jargon in response to questions like \u0026ldquo;Could we add a \u0026lsquo;Save\u0026rsquo; button to this page?\u0026rdquo; is founded in reality: I\u0026rsquo;ve seen it happen. Out of fear of scaring off customers by insisting that they collaborate with engineers, companies install an engineering manager as a buffer between the engineers and the customer.\nWhatever the reason, the truth is that customer collaboration and receiving timely feedback are simply not realities of software development at many, perhaps even most, companies. While managers may say \u0026ldquo;We do Agile here,\u0026rdquo; this is at least half myth.\n","date":"March 6, 2021","permalink":"/posts/2021-03-06-the-agile-myth/","section":"Posts","summary":"Writing a criticism of Agile after the word \u0026ldquo;Agile\u0026rdquo; has been pronounced dead by one of its authors may seem like overkill, but nothing has put a stop to the software industry\u0026rsquo;s glut of Agile certifications, occupations of \u0026ldquo;doing Agile\u0026rdquo;, and every engineering manager I\u0026rsquo;ve ever spoken to saying \u0026ldquo;Oh, yes, we do Agile here.\u0026rdquo; I could write an entire blog post haranguing the profiteering and narcissistic industry (see Dave Thomas\u0026rsquo; post linked above), but today I want to dive deeper, take a hard look at the original document, and ask \u0026ldquo;Who actually does this?","title":"The Agile Myth"},{"content":"","date":"December 13, 2020","permalink":"/tags/functional-programming/","section":"Tags","summary":"","title":"functional programming"},{"content":"","date":"December 13, 2020","permalink":"/tags/nil/","section":"Tags","summary":"","title":"nil"},{"content":"The Problem # Have you ever written code like this?\ndef get_address(address_id) do  case Addresses.get(address_id) do  nil -\u0026gt; {:error, :address_not_found}  val -\u0026gt; {:ok, val}  end end I have. This pattern is commonly used to make the value that Ecto.Repo.get/3 returns (a struct or nil) play well with Elixir\u0026rsquo;s with construct. Since Ecto.Repo.get/3 will always return some single value, a nil check is required to determine whether that value indicates a success or a failure. Doing this check inline is somewhat clumsy:\nwith address when not is_nil(address) \u0026lt;- Addresses.get(address_id) do There\u0026rsquo;s a lot happening in that line, which makes the alternative attractive:\nwith {:ok, address} \u0026lt;- get_address(address_id) do This is a minor complaint, but it points to a much larger issue with nil in Elixir. First, consider the fact that nil serves two purposes:\n Indicate when something cannot be found Represent an empty value; nothingness  While Elixir gives us the convention of :error as the \u0026ldquo;operation did not succeed\u0026rdquo; value, in specific cases nil will also serve that purpose. Why is this an issue? Let me show you an example.\niex(1)\u0026gt; map1 = %{key: nil} %{key: nil} iex(2)\u0026gt; map2 = %{} %{} iex(3)\u0026gt; Map.get(map1, :key) nil iex(4)\u0026gt; Map.get(map2, :key) nil In this example, Map.get/3 returns nil when passed map1 or map2, but for different reasons. In a less contrived scenario, this can lead to some head-scratching bugs. Consider the case where the value associated with a key is intentionally nil to clear out some previously set value in a record. If you were using Map.get/3 to lookup the key in the map, the return value would not indicate if the key and value simply weren\u0026rsquo;t supplied (and thus no corresponding update to the record should occur) or if they were supplied and the value happened to be nil (and the old value in the record should be cleared).\nThis issue is also present with Keyword.get/3, Access.get/3, and even Application.get_env/3.\nThe Remedy # As I alluded to earlier, the remedy here is to take away one of nil\u0026rsquo;s jobs, specifically in indicating failure. The astute among you may have already realized that the third argument (not used in my examples above) to the various get/3 functions is a \u0026ldquo;default\u0026rdquo;. You could certainly change the default to :error whenever you call these functions, but there\u0026rsquo;s likely an even better option.\nEnter fetch/2. For each get/3 function I previously mentioned, there is a fetch/2 equivalent (specifically Map.fetch/2, Keyword.fetch/2, Access.fetch/2, and Application.fetch_env/2). These functions work similarly to their get/3 counterparts, but return {:ok, value} when they succeed and :error otherwise. Consider the Map.get/3 example from earlier, but using Map.fetch/2 instead:\niex(1)\u0026gt; map1 = %{key: nil} %{key: nil} iex(2)\u0026gt; map2 = %{} %{} iex(3)\u0026gt; Map.fetch(map1, :key) {:ok, nil} iex(4)\u0026gt; Map.fetch(map2, :key) :error There is now a clear distinction between the case where the key and value exist and is the value happens to be nil and the case where the lookup has failed. The added bonus of fetch/2 over specifying a default to get/3 is that fetch\u0026rsquo;s {:ok, value} return is more with-friendly.\nwith {:ok, value} \u0026lt;- Map.fetch(map1, :key) do  perform_operation(value) else  :error -\u0026gt; {:error, \u0026#34;Value not found\u0026#34;} end \u0026ldquo;But wait,\u0026rdquo; you might say, \u0026ldquo;what about the example with Ecto.Repo.get/3? Is there an Ecto.Repo.fetch/2?\u0026rdquo;\nSadly, the answer is \u0026ldquo;no.\u0026rdquo; Your only options when looking up a record by its primary key are Ecto.Repo.get/3 and Ecto.Repo.get!/3 (which raises an error when the record is not found).\nIn a way, this makes sense. Since Ecto.Repo.get/3 will always return a struct on success, there is no way a nil return could be confused for anything less than a lookup failure. However, by choosing nil as the failed lookup value, Ecto has pigeon-holed nil into its usage that makes less sense. Should a nil returned by Ecto.Repo.get/3 propagate out the context of Ecto, the confusion over whether it constitutes a failure or an intentionally blank value will ensue.\nWhile the ship has probably sailed on Ecto\u0026rsquo;s API, it hasn\u0026rsquo;t on other libraries and your own code. Whenever you type those three characters into your text editor, make sure it means precisely one thing.\n","date":"December 13, 2020","permalink":"/posts/2020-12-13-harmful-duality-of-elixirs-nil/","section":"Posts","summary":"The Problem # Have you ever written code like this?\ndef get_address(address_id) do  case Addresses.get(address_id) do  nil -\u0026gt; {:error, :address_not_found}  val -\u0026gt; {:ok, val}  end end I have. This pattern is commonly used to make the value that Ecto.Repo.get/3 returns (a struct or nil) play well with Elixir\u0026rsquo;s with construct. Since Ecto.Repo.get/3 will always return some single value, a nil check is required to determine whether that value indicates a success or a failure.","title":"The Harmful Duality of Elixir's nil"},{"content":"Guard Clauses # Once upon a time, Rubocop taught me to love guard clauses. When I first started learning to program, I was deeply conflicted about guard clauses. On the one hand, guard clauses can prevent the need to have deeply nested ifs. On the other hand, it can be hard to remember the context deep into a method without being able to reference the enveloping ifs (similarly to RSpec contexts). In any case, Rubocop wants me to use guard clauses, so I do.\nHere\u0026rsquo;s an example of using a guard clause—if the author is nil, there\u0026rsquo;s no point in continuing with this method.\ndef describe_author(author)  return \u0026#34;\u0026#34; if author.nil?  \u0026#34;#{author.name}(#{author.birth_year}–#{author.death_year})\u0026#34; end Blocks # The Ruby language has a useful construct to contain blocks of code, aptly called \u0026ldquo;blocks.\u0026rdquo; Actually, Ruby has three ways to contain blocks of code—blocks, procs, and lambdas—but this post will just cover blocks.\nGuard Clauses in Blocks # First, in order to use a block, we\u0026rsquo;ll need a function that expects one.\ndef foo  yield if block_given?  puts \u0026#34;End of foo\u0026#34; end This method will execute whatever block we give it first (if we gave it one), then print out a message. Let\u0026rsquo;s give it a block.\nfoo { puts \u0026#34;Inside block!\u0026#34; } #=\u0026gt; Inside block! #=\u0026gt; End of foo Now let\u0026rsquo;s suppose that we want a guard clause in the block that we send.\nreturn # My first inclination on how to do this was with the return keyword. Seeing return in a block, though, would probably raise some questions about whether it\u0026rsquo;s the block that\u0026rsquo;s being returned from or the method that yields to it. Let\u0026rsquo;s try it and find out.\nfoo { return } #=\u0026gt; LocalJumpError: unexpected return It doesn\u0026rsquo;t return from the block or the calling method, it just crashes. Interesting!\nbreak # The break keyword was the next suggestion to come to mind. You may have seen the break keyword used to break out of blocks early in cases like this:\ndef find_first_even(array)  first_even = nil  array.each do |item|  if item.even?  first_even = item  break  end  end  first_even end Of course, this example is completely contrived—one could simply use Array#find here. Regardless, when (or if) an even item in the array is found, first_even is set to that item, and break is used to stop iterating.\nThe break statement documentation has this to say:\n Use break to leave a block early.\n OK! Let\u0026rsquo;s try using break in our block.\nfoo { break } #=\u0026gt; nil What\u0026rsquo;s that? Silence? Something odd has happened here. The end of the foo method had this line:\nputs \u0026#34;End of foo\u0026#34; However, that message wasn\u0026rsquo;t printed to the console. Why?\nIt appears that the break statement in a block actually returns from the calling method. When you consider our example above, this behavior seems to make sense. Array#each calls the given block with each element of the array, in turn. When we call break, it doesn\u0026rsquo;t exit from the block that each would then call again with the next item—it exits from the Array#each call.\nnext # Using this insight, there\u0026rsquo;s another alternative! Let\u0026rsquo;s make another contrived example.\ndef evens_from_array(array)  evens = []  array.each do |item|  next if item.odd?  evens \u0026lt;\u0026lt; item  end  evens end Naturally, you could have just used Array#select instead. In any event, on each iteration, we skip over the rest of the block if the item is odd. This seems like what we want! Let\u0026rsquo;s give it a try.\nfoo { next } #=\u0026gt; End of foo Perfect!\nLet\u0026rsquo;s make a somewhat less contrived example, just to make sure that it really does work the way that we hope. Here is an (admittedly worthless) \u0026ldquo;calculation\u0026rdquo; method.\ndef calculation(a, b)  yield(a, b) end Let\u0026rsquo;s use a guard method to exit from the block early.\ncalculation(23, 0) do |a, b|  next 1 if b == 0 # 23 ** 0 will always be 1.  puts \u0026#34;Calculating...\u0026#34;  a ** b end #=\u0026gt; 1 Great! The \u0026ldquo;Calculating\u0026hellip;\u0026rdquo; message is not printed, as we exited the block prior to that point. Now let\u0026rsquo;s use the same block, but call calculation with arguments that will not trigger the guard clause.\ncalculation(23, 2) do |a, b|  next 1 if b == 0 # 23 ** 0 will always be 1.  puts \u0026#34;Calculating...\u0026#34;  a ** b end #=\u0026gt; Calculating... #=\u0026gt; 529 It works!\nI hope that—in the edge case that you, too, share a preference for guard clauses and find yourself needing to pass some sort of large block—have found this helpful are able to put this knowledge to good use!\nI don\u0026rsquo;t use comments on my site, but if you have some feedback that you\u0026rsquo;d like to share, feel free to tweet at me or send me an email using the links below.\n","date":"October 18, 2017","permalink":"/posts/2017-10-18-escaping-from-ruby-blocks/","section":"Posts","summary":"Guard Clauses # Once upon a time, Rubocop taught me to love guard clauses. When I first started learning to program, I was deeply conflicted about guard clauses. On the one hand, guard clauses can prevent the need to have deeply nested ifs. On the other hand, it can be hard to remember the context deep into a method without being able to reference the enveloping ifs (similarly to RSpec contexts).","title":"Escaping from Ruby Blocks"},{"content":"","date":"October 18, 2017","permalink":"/tags/ruby/","section":"Tags","summary":"","title":"ruby"},{"content":"","date":"August 25, 2016","permalink":"/tags/monkey-patching/","section":"Tags","summary":"","title":"monkey patching"},{"content":"This is the first of a series of posts I intend to write in a new \u0026ldquo;J3RN vs J3RN\u0026rdquo; style. Essentially, I will be stating a problem with two or more possible solutions, taking both sides in turn, and hopefully ultimately reaching a well thought out solution to the problem.\nThe Problem # For my Time Tracker application, I want to have a pretty date and time picker. However, Ruby only natively understands a handful of formats and \u0026ldquo;American date\u0026rdquo;, the format used by the pretty date and time picker, is not one of them.\nThe time specified in the date and picker, available as a string, needs to be converted to a Time instance on save, then converted back into the American date string when displayed.\nMy first solution was to put two methods in a controller, from_american_date and to_american_date, which would perform these functions. However, this approach felt messy. Why should the controller know about converting time formats? What if I need this functionality in another controller?\nI saw two alternatives: Monkey patching Time and creating a new module, AmericanDate.\nTo Monkey Patch # If you look at Ruby\u0026rsquo;s Time class, you will notice that it has an iso8601 class method as well as some rfc**** class methods whose purposes are to parse strings from those formats into Time instances. Additionally, each of these class methods has a corresponding instance method that converts the Time instance into the proper string. Thus, it would make sense to simply define a Time.american_date method to parse Time instances from American date strings and a Time#american_date method to convert Time instances into American date strings.1\nSince Ruby modules can only provide instance methods through include, we will need to separate the class and instance methods into separate modules, which will be added to Time through extend and include, respectively.\n# lib/core_extensions/time/custom_formats.rb module CoreExtensions  module Time  module CustomFormats  AMERICAN_DATE_FORMAT = \u0026#34;%m/%d/%Y %H:%M %p\u0026#34;   module InstanceMethods  def american_date  strftime(AMERICAN_DATE_FORMAT)  end  end   module ClassMethods  def american_date str  strptime(str, AMERICAN_DATE_FORMAT)  end  end  end  end end This results in the following initializer:\n# config/initializers/monkey_patching.rb Time.extend CoreExtensions::Time::CustomFormats::ClassMethods Time.include CoreExtensions::Time::CustomFormats::InstanceMethods Why do it this way? It\u0026rsquo;s elegant. It fits with the other methods in Time and follows Rails conventions.\nNot to Monkey Patch # Ruby gems are almost all modules. Perhaps because of this, perhaps simply because modules are cool, modules are a common way to encapsulate functionality in Ruby, even outside of gems. In fact, this is what the lib directory in a Rails application is for. In order to move our methods out of the controller, we would simply create a module in the lib directory.\n# lib/american_date.rb module AmericanDate  AMERICAN_DATE_FORMAT = \u0026#34;%m/%d/%Y %H:%M %p\u0026#34;   def to_time str  Time.strptime(str, AMERICAN_DATE_FORMAT).in_time_zone  end   def to_string time  time.strftime(AMERICAN_DATE_FORMAT)  end end Done! Wasn\u0026rsquo;t that simple?\nWhy do it this way? It\u0026rsquo;s easy. If I one day want to turn this into a gem (though an American date gem already exists), it would be pretty simple.\nConclusion # I\u0026rsquo;m going to monkey patch Time and add the method to ApplicationHelper. While the module solution is simpler, it doesn\u0026rsquo;t come near the elegance of the monkey patching solution. Hopefully, Monkey patching responsibly will help to avoid many of its pitfalls.\n1 The style of monkey patching I used came from a great blog post by Justin Weiss.\n","date":"August 25, 2016","permalink":"/posts/2016-08-25-to-monkey-patch-ruby/","section":"Posts","summary":"This is the first of a series of posts I intend to write in a new \u0026ldquo;J3RN vs J3RN\u0026rdquo; style. Essentially, I will be stating a problem with two or more possible solutions, taking both sides in turn, and hopefully ultimately reaching a well thought out solution to the problem.\nThe Problem # For my Time Tracker application, I want to have a pretty date and time picker. However, Ruby only natively understands a handful of formats and \u0026ldquo;American date\u0026rdquo;, the format used by the pretty date and time picker, is not one of them.","title":"To Monkey Patch Ruby"},{"content":"Let\u0026rsquo;s talk about interpolation. Sure, you probably know the Ruby string interpolation syntax:\narg = \u0026#34;world\u0026#34; puts \u0026#34;Hello #{arg}!\u0026#34; #=\u0026gt; \u0026#34;Hello world!\u0026#34; This syntax is pretty useful. However, it has it\u0026rsquo;s limitations. Let\u0026rsquo;s say that we are generating strings that are almost the same each time, but with each, one word changes. How are you going to do this now?\nMy first inclination was something like this:\nline = \u0026#34;Today the weather is \\#{ weather }\u0026#34; weather_conditions = {}  [\u0026#34;warm\u0026#34;, \u0026#34;cloudy\u0026#34;, \u0026#34;windy\u0026#34;].each do |weather|  weather_conditions[weather] = %r/line/i end It\u0026rsquo;s not hard to see why this didn\u0026rsquo;t work. Well, it occurred to me shortly thereafter that ERB might be the right way to go with this.\nFirst try with ERB:\nline = \u0026#34;Today the weather is \u0026lt;%= weather %\u0026gt;\u0026#34; weather_conditions = {}  [\u0026#34;warm\u0026#34;, \u0026#34;cloudy\u0026#34;, \u0026#34;windy\u0026#34;].each do |weather|  weather_conditions[weather] = ERB.new(line).result end This endeavor, however, resulted in the following error:\nNameError - undefined local variable or method `weather\u0026#39; for main:Object: After some searching about on the internet, it appears that there is an ever-present binding variable, that is an instance of the Binding class. Strange as that was, it seems to be needed by ERB.new to properly interpolate variables.\nThe final code:\nline = \u0026#34;Today the weather is \u0026lt;%= weather %\u0026gt;\u0026#34; weather_conditions = {}  [\u0026#34;warm\u0026#34;, \u0026#34;cloudy\u0026#34;, \u0026#34;windy\u0026#34;].each do |weather|  weather_conditions[weather] = ERB.new(line).result(binding) end ","date":"December 19, 2014","permalink":"/posts/2014-12-19-interpolating-ruby-strings/","section":"Posts","summary":"Let\u0026rsquo;s talk about interpolation. Sure, you probably know the Ruby string interpolation syntax:\narg = \u0026#34;world\u0026#34; puts \u0026#34;Hello #{arg}!\u0026#34; #=\u0026gt; \u0026#34;Hello world!\u0026#34; This syntax is pretty useful. However, it has it\u0026rsquo;s limitations. Let\u0026rsquo;s say that we are generating strings that are almost the same each time, but with each, one word changes. How are you going to do this now?\nMy first inclination was something like this:\nline = \u0026#34;Today the weather is \\#{ weather }\u0026#34; weather_conditions = {}  [\u0026#34;warm\u0026#34;, \u0026#34;cloudy\u0026#34;, \u0026#34;windy\u0026#34;].","title":"Interpolating Ruby Strings"},{"content":"","date":"December 19, 2014","permalink":"/tags/interpolation/","section":"Tags","summary":"","title":"interpolation"},{"content":"","date":"January 1, 1","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"I get asked this a lot, so I wrote a glorified FAQ page. #   The original reason was social engineering lite. Occasionally I would have to dress up for events in high school, and I noticed that when I did people treated me differently. There\u0026rsquo;s a ton of research into subconscious biases that\u0026rsquo;s honestly really fascinating, but suffice it to say that police officers are usually nicer to well-dressed people that they pull over.\nDoesn\u0026rsquo;t telling us this negate the effect? Probably a bit.\nThere is a flip side: I had to dress down a little bit when I lived in Portland because folks there weren\u0026rsquo;t really keen on suit-and-tie types. Fun Fact™.\n  Closely related, but I\u0026rsquo;m (almost) never underdressed. I tend to forget events (like interviews) but have never had to run home and change.\n  Remove unnecessary decision-making. I hate having to make trivial decisions, and I consider choosing an outfit one of those. I carry a quarter in my wallet for most other ones.\n  \u0026ldquo;What about\u0026hellip; #  working out?\u0026rdquo; I have a separate set of identical workout clothes. yard work?\u0026quot; Same as above. when it\u0026rsquo;s really warm?\u0026quot; I roll up my sleeves; I don\u0026rsquo;t overheat easily. In extreme cases (see Orlando in June), I\u0026rsquo;ll wear yard work clothes. swimming? I think I have some swim trunks somewhere. showering? Seriously?  ","date":"January 1, 1","permalink":"/aesthetic/","section":"J3RN's Blog","summary":"I get asked this a lot, so I wrote a glorified FAQ page. #   The original reason was social engineering lite. Occasionally I would have to dress up for events in high school, and I noticed that when I did people treated me differently. There\u0026rsquo;s a ton of research into subconscious biases that\u0026rsquo;s honestly really fascinating, but suffice it to say that police officers are usually nicer to well-dressed people that they pull over.","title":"Why do you dress that way?"}]