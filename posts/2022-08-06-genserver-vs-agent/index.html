<!doctype html><html lang=en-us dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head>
<meta charset=utf-8>
<meta http-equiv=content-language content="en-us">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="ie=edge">
<title>Elixir GenServers vs Agents &#183; J3RN's Blog</title><meta name=title content="Elixir GenServers vs Agents &#183; J3RN's Blog">
<meta name=description content="My technical blog where I write about Ruby, Elixir, software architecture, software development methodologies, and programming language design.">
<link rel=canonical href=http://j3rn.com/posts/2022-08-06-genserver-vs-agent/>
<link type=text/css rel=stylesheet href=/css/main.bundle.min.6abc21f7ba0acbf25fbd89b4604937a9d0c819366c12551e6fc7604275df8fdf0d06649a47d340f81d48f5d3c6a19aa641621a692e3b24da7949f79921e8d9d8.css integrity="sha512-arwh97oKy/JfvYm0YEk3qdDIGTZsElUeb8dgQnXfj98NBmSaR9NA+B1I9dPGoZqmQWIaaS47JNp5SfeZIejZ2A==">
<script type=text/javascript src=/js/appearance.min.12e98742cd283574d030a7fe55f29597df4ee214f7ff7075b4d19a64d046a602753c715295550be7899b661619cec89c679049d36c624681671a8013c1249896.js integrity="sha512-EumHQs0oNXTQMKf+VfKVl99O4hT3/3B1tNGaZNBGpgJ1PHFSlVUL54mbZhYZzsicZ5BJ02xiRoFnGoATwSSYlg=="></script>
<link rel=icon type=image/png sizes=32x32 href=/images/favicon.ico>
<meta property="og:title" content="Elixir GenServers vs Agents">
<meta property="og:description" content="Elixir and the OTP ecosystem it is built upon offer a variety of different kinds of processes. Two of the most common are GenServer and Agent, which are similar put have different application.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://j3rn.com/posts/2022-08-06-genserver-vs-agent/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-08-06T00:00:00+00:00">
<meta property="article:modified_time" content="2022-08-06T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Elixir GenServers vs Agents">
<meta name=twitter:description content="Elixir and the OTP ecosystem it is built upon offer a variety of different kinds of processes. Two of the most common are GenServer and Agent, which are similar put have different application.">
<script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"Elixir GenServers vs Agents","headline":"Elixir GenServers vs Agents","description":"Elixir and the OTP ecosystem it is built upon offer a variety of different kinds of processes. Two of the most common are GenServer and Agent, which are similar put have different application.","abstract":"Just as Protocols are an abstraction built upon Behaviours, Agents are an abstraction built upon GenServers. While GenServers can serve a wider variety of purposes, Agents serve a single purpose: storing state.\nGenServer # The Elixir documentation for GenServer summarizes them as such:\n A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting.","inLanguage":"en-us","url":"http:\/\/j3rn.com\/posts\/2022-08-06-genserver-vs-agent\/","author":{"@type":"Person","name":"Jonathan Arnett"},"copyrightYear":"2022","dateCreated":"2022-08-06T00:00:00\u002b00:00","datePublished":"2022-08-06T00:00:00\u002b00:00","dateModified":"2022-08-06T00:00:00\u002b00:00","keywords":["elixir"],"mainEntityOfPage":"true","wordCount":"2772"}]</script>
<meta name=author content="Jonathan Arnett">
<script defer data-domain=j3rn.com src=https://plausible.io/js/plausible.js></script>
</head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 bg-neutral text-neutral-900 sm:px-14 md:px-24 lg:px-32 dark:bg-neutral-800 dark:text-neutral max-w-7xl">
<div id=the-top class="absolute flex self-center">
<a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 dark:bg-neutral-600 focus:translate-y-0" href=#main-content><span class="font-bold ltr:pr-2 rtl:pl-2 text-primary-600 dark:text-primary-400">&darr;</span>Skip to main content</a>
</div><header class="py-6 font-semibold sm:py-10 text-neutral-900 dark:text-neutral print:hidden">
<nav class="flex justify-between">
<div>
<a href=/>
<img src=/avatar.png width=250 height=250 class="max-w-[2rem] max-h-[2rem] mr-1 object-scale-down object-left rounded inline-block" alt="J3RN's Blog">
</a>
<a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/>J3RN&rsquo;s Blog</a>
</div><ul class="flex flex-col list-none ltr:text-right rtl:text-left sm:flex-row">
<li class="mb-1 sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0">
<a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/tags/ title=Tags>Tags</a>
</li></ul></nav></header><div class="relative flex flex-col grow">
<main id=main-content class=grow>
<article>
<header class=max-w-prose>
<h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
Elixir GenServers vs Agents
</h1><div class="mt-8 mb-12 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
<div class="flex flex-row flex-wrap items-center">
<time datetime="2022-08-06 00:00:00 +0000 UTC">August 6, 2022</time><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">14 mins</span>
</div></div></header><section class="flex flex-col max-w-full mt-0 prose lg:flex-row dark:prose-invert">
<div class="min-w-0 min-h-0 max-w-prose">
<p>Just as <a href=/posts/2021-10-14-elixir-behaviours-vs-protocols>Protocols are an abstraction built upon Behaviours</a>, Agents are an abstraction built upon GenServers. While GenServers can serve a wider variety of purposes, Agents serve a single purpose: storing state.</p><h2 id=genserver class="relative group">GenServer <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#genserver aria-label=Anchor>#</a></span></h2><p>The <a href=https://hexdocs.pm/elixir/1.13.4/GenServer.html>Elixir documentation for GenServer</a> summarizes them as such:</p><blockquote>
<p>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.</p></blockquote><p>Included in this summary are two potential use-cases for GenServers:</p><ol>
<li>Keep state</li><li>Execute code asynchronously</li></ol><p>Let&rsquo;s explore each of these.</p><h3 id=keeping-state class="relative group">Keeping State <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#keeping-state aria-label=Anchor>#</a></span></h3><p>When the documentation refers to &ldquo;keeping state,&rdquo; it means between processes. In Elixir, data structures cannot (at least not without some trickery) be shared between processes; each process has it&rsquo;s own data, and the only way to share data between processes is by passing messages (e.g. using <a href=https://hexdocs.pm/elixir/1.13.4/Kernel.html#send/2><code>send/2</code></a>). This frees Elixir developers from having to worry about race conditions much of the time, but it also creates a new question of how to allow multiple processes within an Elixir system to have read/write access to a shared piece of data. I have included an example for doing this with both GenServers and Agents in the latter half of this post.</p><h3 id=executing-code-asynchronously class="relative group">Executing Code Asynchronously <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#executing-code-asynchronously aria-label=Anchor>#</a></span></h3><p>The idea here is simple: imagine a web request process wants a report to be generated and an email sent, but also doesn&rsquo;t want to have to wait until those are finished before sending a response to the user.</p><p>Enter GenServer. When an application has a dedicated GenServer process to perform a specific task, other processes can request the GenServer to perform its task by sending it a message, and then continue on with their other work<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>While doing this with Agent <em>is possible</em> it&rsquo;s not the intended use of Agent, and so should be avoided.</p><h2 id=agent class="relative group">Agent <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#agent aria-label=Anchor>#</a></span></h2><p><a href=https://hexdocs.pm/elixir/1.13.4/Agent.html>The Elixir documentation for Agent</a> summarizes them simply as:</p><blockquote>
<p>Agents are a simple abstraction around state.</p></blockquote><p>The commentary around &ldquo;Keeping State&rdquo; from the GenServer section above applies here, with the noted caveat that Agents are <em>optimized</em> for this use case.</p><h2 id=feature-comparison class="relative group">Feature Comparison <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#feature-comparison aria-label=Anchor>#</a></span></h2><p>Agents surface much, but not all, of the functionality from their underlying GenServers.</p><table>
<thead>
<tr>
<th>Feature</th><th>GenServer Support</th><th>Agent Support</th></tr></thead><tbody>
<tr>
<td>call (send message and await response)</td><td>Yes</td><td>Yes</td></tr><tr>
<td>cast (send message without waiting for response)</td><td>Yes</td><td>Yes</td></tr><tr>
<td>info (receive arbitrary messages sent with <code>send/2</code>)</td><td>Yes</td><td>No</td></tr><tr>
<td>continue (init function can continue async)</td><td>Yes</td><td>No</td></tr><tr>
<td>terminate (custom behavior on shutdown)</td><td>Yes</td><td>No</td></tr><tr>
<td>code change (custom code update handling)</td><td>Yes</td><td><a href=https://hexdocs.pm/elixir/1.13.4/Agent.html#module-hot-code-swapping>Sort-of</a></td></tr></tbody></table><p>Additionally, the <code>Agent</code> module provides a variety of <a href=https://hexdocs.pm/elixir/1.13.4/Access.html><code>Access</code></a>-like functions that help the user think of it as a datastructure instead of a process, such as:</p><ul>
<li><a href=https://hexdocs.pm/elixir/1.13.4/Agent.html#get/3><code>get/3</code></a>, <a href=https://hexdocs.pm/elixir/1.13.4/Agent.html#get/5><code>get/5</code></a></li><li><a href=https://hexdocs.pm/elixir/1.13.4/Agent.html#update/3><code>update/3</code></a>, <a href=https://hexdocs.pm/elixir/1.13.4/Agent.html#update/5><code>update/5</code></a></li><li><a href=https://hexdocs.pm/elixir/1.13.4/Agent.html#get_and_update/3><code>get_and_update/3</code></a>, <a href=https://hexdocs.pm/elixir/1.13.4/Agent.html#get_and_update/5><code>get_and_update/5</code></a></li></ul><p>The utility of these, and the advantages they provide over coding the same functionality with a GenServer, is best shown through an example.</p><h2 id=example class="relative group">Example <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#example aria-label=Anchor>#</a></span></h2><p>Let&rsquo;s say that we&rsquo;re creating a bulletin board where users can post new messages. Each request that comes into the bulletin board system is either posting a new message or reading the messages that have been posted.</p><p>
<figure>
<img class="my-0 rounded-md" src=/images/bulletin_board.jpg alt="A bulletin board with notes on it">
</figure></p><p>With Phoenix, as well as with other Elixir/Erlang web frameworks, each request is handled in its own process. Thus, the request-handling process&rsquo; state will only include a few things that have been given to it—most likely <em>not</em> including our repository of messages. These request processes need to be able to read or write to a shared repository of messages.</p><p>Let&rsquo;s create a GenServer to hold the messages<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>!</p><p>Conventionally, the first place to start is by defining a module and calling <code>use GenServer</code> within it:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#c678dd>defmodule</span> <span style=color:#76a9f9>BBS.MessageRepository</span> <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>use</span> <span style=color:#76a9f9>GenServer</span>
</span></span></code></pre></div><p>Next, we&rsquo;ll define our server functionality. This consists of an <code>init/1</code> function which is invoked when the server starts up and a <code>handle_call/3</code> function which is invoked when the server receives a message<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>  <span style=color:#8a93a5;font-style:italic># Server</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>init</span>(<span style=color:#c1abea>messages</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    {<span style=color:#56b6c2>:ok</span>, <span style=color:#c1abea>messages</span>}
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>handle_call</span>({<span style=color:#56b6c2>:post</span>, <span style=color:#c1abea>message</span>}, <span style=color:#c1abea>_from</span>, <span style=color:#c1abea>messages</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    {<span style=color:#56b6c2>:reply</span>, <span style=color:#56b6c2>:ok</span>, [<span style=color:#c1abea>message</span> <span style=color:#c7bf54>|</span> <span style=color:#c1abea>messages</span>]}
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>handle_call</span>(<span style=color:#56b6c2>:read_all</span>, <span style=color:#c1abea>_from</span>, <span style=color:#c1abea>messages</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    {<span style=color:#56b6c2>:reply</span>, <span style=color:#c1abea>messages</span>, <span style=color:#c1abea>messages</span>}
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span></code></pre></div><p>Our <code>init/1</code> allows the server to be initialized with a list of messages, which we use as the initial state. The return value <code>{:ok, messages}</code> indicates that the server started successfully and we want our GenServer&rsquo;s state to be <code>messages</code>.</p><p>Our <code>handle_call/3</code> function can handle two kinds of incoming messages:</p><ol>
<li><code>{:post, message}</code>, which requests that <code>message</code> be posted to the bulletin board</li><li><code>:read_all</code>, which requests all of the messages on the bulletin board</li></ol><p>The return value in both cases takes the form <code>{:reply, response, new_state}</code>. There are other allowable formats for return values of <code>handle_call/2</code>, but this is the only one we need for this example.</p><p>If we ended our module here, a client could use this code like so:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#c1abea>iex</span>(<span style=color:#d19a66>1</span>)<span style=color:#c7bf54>&gt;</span> {<span style=color:#56b6c2>:ok</span>, <span style=color:#c1abea>pid</span>} <span style=color:#c7bf54>=</span> <span style=color:#76a9f9>GenServer</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>start_link</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, [<span style=color:#63c381>&#34;Welcome to My Bulletin Board!&#34;</span>])
</span></span><span style=display:flex><span>{<span style=color:#56b6c2>:ok</span>, <span style=color:#8a93a5;font-style:italic>#PID&lt;0.163.0&gt;}</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>iex</span>(<span style=color:#d19a66>2</span>)<span style=color:#c7bf54>&gt;</span> <span style=color:#76a9f9>GenServer</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>call</span>(<span style=color:#c1abea>pid</span>, {<span style=color:#56b6c2>:post</span>, <span style=color:#63c381>&#34;Block Party!&#34;</span>})
</span></span><span style=display:flex><span><span style=color:#56b6c2>:ok</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>iex</span>(<span style=color:#d19a66>3</span>)<span style=color:#c7bf54>&gt;</span> <span style=color:#76a9f9>GenServer</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>call</span>(<span style=color:#c1abea>pid</span>, <span style=color:#56b6c2>:read_all</span>)
</span></span><span style=display:flex><span>[<span style=color:#63c381>&#34;Block Party!&#34;</span>, <span style=color:#63c381>&#34;Welcome to My Bulletin Board!&#34;</span>]
</span></span></code></pre></div><p><em>Your PID will almost certainly be different—this is to be expected!</em></p><p>This isn&rsquo;t very convenient, though, and each request process shouldn&rsquo;t call <code>GenServer.start_link</code> start it&rsquo;s own server—that would defeat the purpose!—they need to share one server.</p><p>Let&rsquo;s fix this by configuring our application start the server. If your Elixir app was generated with a supervision tree (i.e. you passed <code>--sup</code> to <code>mix new</code> or are using Phoenix/another framework), you should have an <code>application.ex</code> file, e.g. <code>lib/bbs/application.ex</code>. This file is where the application&rsquo;s supervision tree is defined, and processes specified in the list of children will be started when your application boots. Let&rsquo;s add our message repository as a child in this list.</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>    <span style=color:#c1abea>children</span> <span style=color:#c7bf54>=</span> [
</span></span><span style=display:flex><span>      %{
</span></span><span style=display:flex><span>        <span style=color:#56b6c2>id</span>: <span style=color:#76a9f9>BBS.MessageRepository</span>,
</span></span><span style=display:flex><span>        <span style=color:#56b6c2>start</span>:
</span></span><span style=display:flex><span>          {<span style=color:#76a9f9>GenServer</span>, <span style=color:#56b6c2>:start_link</span>,
</span></span><span style=display:flex><span>           [
</span></span><span style=display:flex><span>             <span style=color:#76a9f9>BBS.MessageRepository</span>,
</span></span><span style=display:flex><span>             [<span style=color:#63c381>&#34;Welcome to My Bulletin Board!&#34;</span>],
</span></span><span style=display:flex><span>             [<span style=color:#56b6c2>name</span>: <span style=color:#76a9f9>BBS.MessageRepository</span>]
</span></span><span style=display:flex><span>           ]}
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    ]
</span></span></code></pre></div><p>This is a bit verbose, but we&rsquo;ll clean it up later. The key concept here is that the <code>children</code> list should be reducible to a list of maps that at least have an <code>:id</code> key—whose value is used internally by the supervisor to identify this child—and a <code>:start</code> key—whose value is a Module-Function-Arguments (MFA) tuple that indicates what function to call to start the process.</p><p>You may have noticed that <code>[name: BBS.MessageRepository]</code> was added as a third argument to <code>GenServer.start_link</code>. When <code>:name</code> refers to an atom (and in Elixir, modules are atoms), that atom is registered as the node-local name for the process. With the name registered, we can use the name instead of the PID when invoking <code>GenServer.call/2</code> (and other process communication functions such as <code>send/2</code>). By convention, the name of the module that defines the process is used as the process name.</p><p>With this in place, our application will start a shared message repository which we can immediately access by its name:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#c1abea>iex</span>(<span style=color:#d19a66>1</span>)<span style=color:#c7bf54>&gt;</span> <span style=color:#76a9f9>GenServer</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>call</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, {<span style=color:#56b6c2>:post</span>, <span style=color:#63c381>&#34;Block Party!&#34;</span>})
</span></span><span style=display:flex><span><span style=color:#56b6c2>:ok</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>iex</span>(<span style=color:#d19a66>2</span>)<span style=color:#c7bf54>&gt;</span> <span style=color:#76a9f9>GenServer</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>call</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#56b6c2>:read_all</span>)
</span></span><span style=display:flex><span>[<span style=color:#63c381>&#34;Block Party!&#34;</span>, <span style=color:#63c381>&#34;Welcome to My Bulletin Board!&#34;</span>]
</span></span></code></pre></div><p>This works pretty well. However, it&rsquo;s conventional in Elixir to use wrapper &ldquo;client&rdquo; functions instead of calling GenServer functions directly from your application code. This is especially important when data flowing from your application into the GenServer or vice versa require a bit of processing. That&rsquo;s not the case for us, but we&rsquo;ll define client functions anyways for the sake of convention. We&rsquo;ll put these below the server functions in the <code>BBS.MessageRepository</code> module<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>  <span style=color:#8a93a5;font-style:italic># Client</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>post</span>(<span style=color:#c1abea>message</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>GenServer</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>call</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, {<span style=color:#56b6c2>:post</span>, <span style=color:#c1abea>message</span>})
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>read_all</span>() <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>GenServer</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>call</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#56b6c2>:read_all</span>)
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span></code></pre></div><p>Now, from anywhere in our application we can simply invoke <code>BBS.MessageRepository.post("Block Party!")</code> to post a message about a block party and <code>BBS.MessageRepository.read_all()</code> to read all existing messages. Not too shabby!</p><p>You can view <a href=https://github.com/J3RN/BBS/blob/55d0215ec0e2c583fc2e2d92cd241653ac59a942/lib/bbs/message_respository.ex>this first iteration of <code>BBS.MessageRepository</code> on GitHub</a>.</p><p>Lastly, the cleanup I mentioned before. At the very bottom of our <code>BBS.MessageRepository</code> module we can define a <code>start_link/1</code> function like so:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>start_link</span>(<span style=color:#c1abea>messages</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>GenServer</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>start_link</span>(
</span></span><span style=display:flex><span>      <span style=color:#76a9f9>BBS.MessageRepository</span>,
</span></span><span style=display:flex><span>      <span style=color:#c1abea>messages</span>,
</span></span><span style=display:flex><span>      <span style=color:#56b6c2>name</span>: <span style=color:#76a9f9>BBS.MessageRepository</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>end</span>
</span></span></code></pre></div><p>The key incentive to doing this is that it allows us to simplify the specification for this process in the children list of the application supervisor:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>    <span style=color:#c1abea>children</span> <span style=color:#c7bf54>=</span> [
</span></span><span style=display:flex><span>      {<span style=color:#76a9f9>BBS.MessageRepository</span>, [<span style=color:#63c381>&#34;Welcome to My Bulletin Board!&#34;</span>]}
</span></span><span style=display:flex><span>    ]
</span></span></code></pre></div><p>Additionally, moving the logic regarding how the process starts into the module where other aspects of process are defined lowers the coupling from our application module to our process module. For instance, if we wanted to change how the <code>BBS.MessageRepository</code> process was started (<em>cough</em> foreshadowing <em>cough</em>), we would only have to update the <code>BBS.MessageRepository</code> module.</p><p>You can view <a href=https://github.com/J3RN/BBS/blob/d5e2f7a5677a8e37b4d6a8e02c1574cfcfe4c5cc/lib/bbs/message_respository.ex>this slightly expanded <code>BBS.MessageRepository</code></a> and <a href=https://github.com/J3RN/BBS/blob/d5e2f7a5677a8e37b4d6a8e02c1574cfcfe4c5cc/lib/bbs/application.ex>the terser <code>application.ex</code></a> on GitHub.</p><aside>
<h4 id=how-does-specifying-a-child-with-a-tuple-work class="relative group">How Does Specifying a Child with a Tuple Work? <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#how-does-specifying-a-child-with-a-tuple-work aria-label=Anchor>#</a></span></h4><p>Unfortunately, it&rsquo;s a bit complicated.</p><p>Per <a href=https://hexdocs.pm/elixir/1.13.4/Supervisor.html#module-child_spec-1>the Supervisor documentation</a>, children can be specified by:</p><ul>
<li>A map, as discussed previously</li><li>A module</li><li>A <code>{module, arg}</code> tuple, as used above</li><li>A six-element tuple (deprecated)</li></ul><p>The list of child specifications is passed to <code>Supervisor.start_link/2</code>, where they are passed to <code>Supervisor.init/2</code>, and subsequently to <code>Supervisor.init_child/1</code> (private), which is responsible for turning each of these into the previously discussed map format (except for the sextuple format, but I&rsquo;m ignoring that because it&rsquo;s deprecated).</p><p>When <code>Supervisor.init_child/1</code> is given a map, its work is already complete and the map is returned without any changes. When only a module is given, it is wrapped in a tuple with an empty list and passed again to <code>Supervisor.init_child/1</code>. When a tuple containing a module and some second element (&ldquo;the argument&rdquo;) is given, <code>Supervisor.init_child/1</code> assumes that the module defines a <code>child_spec/1</code> function that, when called with the argument, will return the desired map.</p><p>&ldquo;But wait,&rdquo; you say, &ldquo;we didn&rsquo;t define a <code>child_spec/1</code> function in <code>BBS.MessageRepository</code>!&rdquo; You&rsquo;re correct. However, when we invoke <code>use GenServer</code> at the top of the <code>BBS.MessageRepository</code> module, <a href=https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/gen_server.ex#L742-L843><code>GenServer</code>&rsquo;s <code>__using__</code> macro</a> is invoked, which defines a <code>child_spec/1</code> for us. This generated <code>child_spec/1</code> function returns a map that specifies the module&rsquo;s name as the <code>:id</code>—which we did before, so that&rsquo;s fine—and refers to a local <code>start_link/1</code> function for the <code>:start</code> key. Thus, we needed to define a <code>start_link/1</code> function to start our server process, which we did above.</p><p>You can override this generated <code>child_spec/1</code> function by simply defining such a function within the module body, if needed.</p><p>This functionality allows us to avoid some boilerplate when specifying children processes for a supervisor and avoid the aforementioned coupling, but comes at the cost of being a bit convoluted when you&rsquo;re trying to figure out how it works.</p></aside><p>This wraps up a basic example of storing state with a GenServer.</p><p>Let&rsquo;s refactor our <code>BBS.MessageRepository</code> module to use Agent instead of GenServer. Firstly, we&rsquo;ll change <code>use GenServer</code> to <code>use Agent</code>:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#c678dd>defmodule</span> <span style=color:#76a9f9>BBS.MessageRepository</span> <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>use</span> <span style=color:#76a9f9>Agent</span>
</span></span></code></pre></div><p>Easy enough! Next, we&rsquo;ll need to change our <code>init/1</code> function very subtly:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>  <span style=color:#8a93a5;font-style:italic># Server</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>init</span>(<span style=color:#c1abea>messages</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#c1abea>messages</span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span></code></pre></div><p>Did you notice the change? We changed the return value from <code>{:ok, messages}</code> to just <code>messages</code>. Agents don&rsquo;t appear to have a method to specify that the server initialization failed, whereas GenServers&rsquo; <code>init/1</code> may return <code>:ignore</code> or <code>{:stop, reason}</code> to indicate that the server should not be started. Regardless, this isn&rsquo;t a problem for us in this example.</p><p>Next, we&rsquo;re going to convert our <code>handle_call/2</code> function clauses into two new functions: <code>handle_post/2</code> and <code>handle_read_all/1</code>. You&rsquo;ll see why this is necessary soon.</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>handle_post</span>(<span style=color:#c1abea>messages</span>, <span style=color:#c1abea>message</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    [<span style=color:#c1abea>message</span> <span style=color:#c7bf54>|</span> <span style=color:#c1abea>messages</span>]
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>handle_read_all</span>(<span style=color:#c1abea>messages</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#c1abea>messages</span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span></code></pre></div><p>Again, we&rsquo;ve been able to dispose of some syntactic noise—we don&rsquo;t take <code>from</code> as an argument (which we didn&rsquo;t use anyways) and don&rsquo;t have to wrap our return values in <code>{:reply, response, new_state}</code> tuples. Speaking of which, something interesting to note is that <code>handle_post/2</code> returns only the new state and <code>handle_read_all/1</code> only returns a response for the client (which is coincidentally also the state here, but doesn&rsquo;t need to be). These functions also now take different numbers of arguments! These changes are facilitated by the <code>Agent</code> functions we&rsquo;ll be using in our updated client functions.</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>  <span style=color:#8a93a5;font-style:italic># Client</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>post</span>(<span style=color:#c1abea>message</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>Agent</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>update</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#56b6c2>:handle_post</span>, [<span style=color:#c1abea>message</span>])
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>read_all</span>() <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>Agent</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>get</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#56b6c2>:handle_read_all</span>, [])
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span></code></pre></div><p>In <code>post/1</code>, we make use of <code>Agent.update</code> which takes the name of a running Agent as the first argument—we&rsquo;re still naming the process after the module, per convention—and a module, function, and arguments for the next three arguments (essentially an MFA tuple, discussed earlier). The specified function will receive the Agent&rsquo;s state as its first argument and the arguments specified in the <code>Agent.update</code> call as subsequent arguments. The return value of this function will be the new state for the Agent. <code>Agent.update</code> always returns <code>:ok</code>.</p><p>The implementation of <code>read_all</code> is similar, except that the return value of the function specified to <code>Agent.get</code> will be the return value of <code>Agent.get</code> and has no impact on the Agent&rsquo;s state.</p><p>A nicety of this approach is the ability to assign arbitrary names to the handler functions, whereas with GenServer they had to be clauses of the <code>handle_call</code> function.</p><p>Lastly, let&rsquo;s update our <code>start_link/1</code> function:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>start_link</span>(<span style=color:#c1abea>messages</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>Agent</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>start_link</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#56b6c2>:init</span>, [<span style=color:#c1abea>messages</span>], <span style=color:#56b6c2>name</span>: <span style=color:#76a9f9>BBS.MessageRepository</span>)
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>end</span>
</span></span></code></pre></div><p>This didn&rsquo;t change all that much; we swapped &ldquo;GenServer&rdquo; for &ldquo;Agent&rdquo;, now have to specify that we want the <code>init</code> function (which was implicit before), and also need to wrap <code>messages</code> in a list to make our first three arguments essentially and MFA tuple. A side effect of this is that we could now pass additional arguments to <code>init</code>, if we wanted, or even renamed <code>init</code>, but that&rsquo;s not necessary for this example.</p><aside>
<p>You can view <a href=https://github.com/J3RN/BBS/blob/fc4501ec20d4886505df76bc940716909a95b689/lib/bbs/message_respository.ex>the entire module with Agent on GitHub</a>.</p><h4 id=clientserver-separation class="relative group">Client/Server Separation <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#clientserver-separation aria-label=Anchor>#</a></span></h4><p>Being able to specify the module for the handler functions makes it pretty easy to create a dedicated server module. For instance, we could move our server functions (<code>handle_post/2</code>, <code>handle_read_all/1</code>, and <code>init/1</code>) into a new <code>BBS.MessageRepository.Server</code> module and make that module&rsquo;s name the second argument in the <code>Agent.get</code> and <code>Agent.update</code> function calls above and the first argument in <code>Agent.start_link</code>. <em>Voila!</em> With these changes, we would have a clear separation of what code runs inside the Agent process from what code runs in the calling (or client) process.</p><p>We also could have split the server functions from the client functions with our GenServer implementation, but it would be more involved.</p></aside><p>If you can believe it, this code can become even more concise! Instead of passing a module, function, and arguments to the <code>Agent</code> functions, we can pass an anonymous function instead. Here, we&rsquo;ll combine our client and server functions such that the server portion is just an anonymous function inside the client functions:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#c678dd>defmodule</span> <span style=color:#76a9f9>BBS.MessageRepository</span> <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>use</span> <span style=color:#76a9f9>Agent</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>post</span>(<span style=color:#c1abea>message</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>Agent</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>update</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#c678dd>fn</span> <span style=color:#c1abea>messages</span> <span style=color:#c7bf54>-&gt;</span>
</span></span><span style=display:flex><span>      [<span style=color:#c1abea>message</span> <span style=color:#c7bf54>|</span> <span style=color:#c1abea>messages</span>]
</span></span><span style=display:flex><span>    <span style=color:#c678dd>end</span>)
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>read_all</span>() <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>Agent</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>get</span>(<span style=color:#76a9f9>BBS.MessageRepository</span>, <span style=color:#c678dd>fn</span> <span style=color:#c1abea>messages</span> <span style=color:#c7bf54>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#c1abea>messages</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>end</span>)
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#c678dd>def</span> <span style=color:#c1abea>start_link</span>(<span style=color:#c1abea>messages</span>) <span style=color:#c678dd>do</span>
</span></span><span style=display:flex><span>    <span style=color:#76a9f9>Agent</span><span style=color:#c7bf54>.</span><span style=color:#c1abea>start_link</span>(<span style=color:#c678dd>fn</span> <span style=color:#c7bf54>-&gt;</span> <span style=color:#c1abea>messages</span> <span style=color:#c678dd>end</span>, <span style=color:#56b6c2>name</span>: <span style=color:#76a9f9>BBS.MessageRepository</span>)
</span></span><span style=display:flex><span>  <span style=color:#c678dd>end</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>end</span>
</span></span></code></pre></div><p>That&rsquo;s it! Those 19 lines of code constitute our entire message repository process! This level of brevity is not available with GenServer, only with Agent.</p><p>If you&rsquo;d like to see <a href=https://github.com/J3RN/BBS/blob/c679c7c3c07703901d2ee0ef275ff91757ef00dd/lib/bbs/message_respository.ex>this terser Agent version on GitHub</a>, that&rsquo;s also an option.</p><p>The downside to this condensed code, in my opinion, is that the separation between what code runs in the server process from what code runs in the client process is at its fuzziest. I can imagine confusing what runs where when giving this code a quick skim.</p><h2 id=conclusion class="relative group">Conclusion <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#conclusion aria-label=Anchor>#</a></span></h2><p>GenServers and Agents are both kinds of processes defined within Elixir. The former allows for great flexibility and different use cases whereas the latter is optimized an implementation of the former for allowing processes to read/write access to a single piece of data.</p><p>I hope that this post has given you the knowledge to make the right choice for your application!</p><section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>The process mailbox acts like a FIFO queue; messages sent first will be processed first. However it&rsquo;s worth noting that if the receiving process dies for any reason, it&rsquo;s mailbox—and thus queue of work—will be lost.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote>
<p>This works well for prototyping, but you should be aware that when the GenServer process dies, all the data that it was holding will be lost. For a more persistent data store, you&rsquo;ll want to use either <a href=https://www.erlang.org/doc/man/dets.html>DETS</a> or an external database such as Redis or PostgreSQL.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote>
<p>There are other kinds of messages that can be received by a GenServer—including cast messages and info messages, handled by <a href=https://hexdocs.pm/elixir/GenServer.html#c:handle_cast/2><code>handle_cast/2</code></a> and <a href=https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2><code>handle_info/2</code></a>, respectively—but I only cover call messages in this post.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote>
<p>I&rsquo;m not a fan of having client functions and server functions in the same file, especially if they contain any amount of logic, but this is the Elixir convention. Dave Thomas explores this in his talk <a href="https://www.youtube.com/watch?v=6U7cLUygMeI">&ldquo;I Write Bad Elixir. So Do You!&rdquo;</a>. Humorously <code>Agent</code> bucks the convention and splits client and server, with the <code>Agent</code> module containing the client functions and the <code>Agent.Server</code> module containing the server functions.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></section><footer class="pt-8 max-w-prose print:hidden">
<div class=pt-8>
<hr class="border-dotted border-neutral-300 dark:border-neutral-600">
<div class="flex justify-between pt-3">
<span>
<a class="flex group" href=/posts/2022-04-01-focusing-on-what-matters/>
<span class="mr-3 ltr:inline rtl:hidden text-neutral-700 dark:text-neutral group-hover:text-primary-600 dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 ltr:hidden rtl:inline text-neutral-700 dark:text-neutral group-hover:text-primary-600 dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col">
<span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Focusing on What Matters</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
<time datetime="2022-04-01 00:00:00 +0000 UTC">April 1, 2022</time>
</span>
</span>
</a>
</span>
<span>
</span>
</div></div></footer></article><div class="absolute top-[100vh] ltr:right-0 rtl:left-0 w-12 pointer-events-none bottom-0">
<a href=#the-top class="w-12 h-12 sticky pointer-events-auto top-[calc(100vh-5.5rem)] bg-neutral/50 dark:bg-neutral-800/50 backdrop-blur rounded-full text-xl flex items-center justify-center text-neutral-700 dark:text-neutral hover:text-primary-600 dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">
&uarr;
</a>
</div></main><footer class="py-10 print:hidden">
<div class="flex items-center justify-between">
<div>
<p class="text-sm text-neutral-500 dark:text-neutral-400">
&copy;
2022
Jonathan Arnett
</p><p class="text-xs text-neutral-500 dark:text-neutral-400">
Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://git.io/hugo-congo target=_blank rel="noopener noreferrer">Congo</a>
</p></div></div></footer></div></body></html>