<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>J3RN's Blog</title><link>http://j3rn.com/</link><description>Recent content on J3RN's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 06 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://j3rn.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Elixir GenServers vs Agents</title><link>http://j3rn.com/posts/2022-08-06-genserver-vs-agent/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/2022-08-06-genserver-vs-agent/</guid><description>Just as Protocols are an abstraction built upon Behaviours, Agents are an abstraction built upon GenServers. While GenServers can serve a wider variety of purposes, Agents serve a single purpose: storing state.
GenServer # The Elixir documentation for GenServer summarizes them as such:
A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting.</description></item><item><title>Focusing on What Matters</title><link>http://j3rn.com/posts/2022-04-01-focusing-on-what-matters/</link><pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/2022-04-01-focusing-on-what-matters/</guid><description>In an introductory computer science course, our professor instructed us:
Don&amp;rsquo;t become attached to any IDE, text editor, programming language, or operating system. This field is young and constantly evolving; you don&amp;rsquo;t want to be left behind.
I don&amp;rsquo;t think I realized at that time what tremendously insightful advice this was. At that time I was primarily writing Java in Eclipse. Over the next few years I would work professionally in PHP and Ruby and then later migrate to Elixir.</description></item><item><title>Profiling Elixir for Advent of Code</title><link>http://j3rn.com/posts/2021-12-05-profiling-elixir-for-advent-of-code/</link><pubDate>Sun, 05 Dec 2021 15:34:07 -0500</pubDate><guid>http://j3rn.com/posts/2021-12-05-profiling-elixir-for-advent-of-code/</guid><description>Every now and again, you may run into a problem that isn&amp;rsquo;t hard to solve using functional programming, but which is hard to solve quickly using functional programming. For me, today, that problem was Advent of Code, Day 5.
If you&amp;rsquo;re participating in Advent of Code and you haven&amp;rsquo;t yet solved Day 5, this is your last chance to leave the page without spoilers. You have been warned!
The Problem # You are provided with a list of lines of hydrothermal vents on the ocean floor.</description></item><item><title>Truly Declarative: Logic Programming</title><link>http://j3rn.com/posts/2021-10-30-truly-declarative-logic-programming/</link><pubDate>Sat, 30 Oct 2021 10:21:19 -0400</pubDate><guid>http://j3rn.com/posts/2021-10-30-truly-declarative-logic-programming/</guid><description>While reading through Miran Lipovača&amp;rsquo;s excellent Learn You a Haskell, I came across the following problem:
Which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24?
To demonstrate some properties of different programming languages, I&amp;rsquo;ll solve this problem in three languages embodying three different paradigms:
C (imperative and procedural) Haskell (functional) Prolog (logic and constraint) C # The general approach I&amp;rsquo;ll be taking here is to generate every set of possible lengths fitting the constraints (namely being integers between 1 and 10) and then check to see if the other two conditions are met (being a right triangle, having a perimeter of 24).</description></item><item><title>Elixir Behaviours vs Protocols</title><link>http://j3rn.com/posts/2021-10-14-elixir-behaviours-vs-protocols/</link><pubDate>Thu, 14 Oct 2021 22:40:42 -0400</pubDate><guid>http://j3rn.com/posts/2021-10-14-elixir-behaviours-vs-protocols/</guid><description>As developers begin learning Elixir, they often have a very understandable confusion around the difference between Elixir&amp;rsquo;s behaviours and protocols. These are similar constructs, but with important differences.
Behaviours # Behaviours are conceptually quite simple:
A behaviour module defines a set of functions and macros (referred to as callbacks) that callback modules implementing that behaviour must export.
For instance, a commonly used behaviour is GenServer, used like so:</description></item><item><title>Exciting Changes Coming in Elixir 1.12</title><link>http://j3rn.com/posts/2021-04-14-elixir-1.12/</link><pubDate>Wed, 14 Apr 2021 15:10:00 -0500</pubDate><guid>http://j3rn.com/posts/2021-04-14-elixir-1.12/</guid><description>José recently announced the availability of Elixir 1.12.0 rc.0, a precursor to the full Elixir 1.12.0 release which should come within the next month or so. This update consists primarily of developer quality-of-life improvements. In his announcement, José elaborated on a few changes, but I couldn&amp;rsquo;t help but feel that some exciting changes were relegated to footnotes. As such, I&amp;rsquo;m dedicating this post to trawling through the full changelog and shining a spotlight on a few of my favorite changes.</description></item><item><title>The Agile Myth</title><link>http://j3rn.com/posts/2021-03-06-the-agile-myth/</link><pubDate>Sat, 06 Mar 2021 15:10:00 -0500</pubDate><guid>http://j3rn.com/posts/2021-03-06-the-agile-myth/</guid><description>Writing a criticism of Agile after the word Agile has been pronounced dead by one of its authors may seem like overkill, but nothing has put a stop to the software industry&amp;rsquo;s glut of Agile certifications, occupations of &amp;ldquo;doing Agile&amp;rdquo;, and every engineering manager I&amp;rsquo;ve ever talked to saying &amp;ldquo;Oh, yes, we do Agile here.&amp;rdquo; I could write an entire blog post haranguing the profiteering and narcissistic industry (see Dave Thomas&amp;rsquo; post linked above), but today I want to dive deeper, take a hard look at the original document, and ask &amp;ldquo;Who actually does this?</description></item><item><title>The Harmful Duality of Elixir's nil</title><link>http://j3rn.com/posts/2020-12-13-harmful-duality-of-elixirs-nil/</link><pubDate>Sun, 13 Dec 2020 20:46:00 -0500</pubDate><guid>http://j3rn.com/posts/2020-12-13-harmful-duality-of-elixirs-nil/</guid><description>The Problem # Have you ever written code like this?
def get_address(address_id) do case Addresses.get(address_id) do nil -&amp;gt; {:error, :address_not_found} val -&amp;gt; {:ok, val} end end I have. This pattern is commonly used to make the value that Ecto.Repo.get/3 returns (a struct or nil) play well with Elixir&amp;rsquo;s with construct. Since Ecto.Repo.get/3 will always return some single value, a nil check is required to determine whether that value indicates a success or a failure.</description></item><item><title>Escaping from Ruby Blocks</title><link>http://j3rn.com/posts/2017-10-18-escaping-from-ruby-blocks/</link><pubDate>Wed, 18 Oct 2017 12:00:00 -0400</pubDate><guid>http://j3rn.com/posts/2017-10-18-escaping-from-ruby-blocks/</guid><description>Guard Clauses # Once upon a time, Rubocop taught me to love guard clauses. When I first started learning to program, I was deeply conflicted about guard clauses. On the one hand, guard clauses can prevent the need to have deeply nested ifs. On the other hand, it can be hard to remember the context deep into a method without being able to reference the enveloping ifs (similarly to RSpec contexts).</description></item><item><title>To Monkey Patch Ruby</title><link>http://j3rn.com/posts/2016-08-25-to-monkey-patch-ruby/</link><pubDate>Thu, 25 Aug 2016 16:07:49 -0400</pubDate><guid>http://j3rn.com/posts/2016-08-25-to-monkey-patch-ruby/</guid><description>This is the first of a series of posts I intend to write in a new &amp;ldquo;J3RN vs J3RN&amp;rdquo; style. Essentially, I will be stating a problem with two or more possible solutions, taking both sides in turn, and hopefully ultimately reaching a well thought out solution to the problem.
The Problem # For my Time Tracker application, I want to have a pretty date and time picker. However, Ruby only natively understands a handful of formats and &amp;ldquo;American date&amp;rdquo;, the format used by the pretty date and time picker, is not one of them.</description></item><item><title>Rage Against the Unintelligent Machine</title><link>http://j3rn.com/posts/2016-01-13-rage-against-the-unintelligent-machine/</link><pubDate>Wed, 13 Jan 2016 10:08:00 -0500</pubDate><guid>http://j3rn.com/posts/2016-01-13-rage-against-the-unintelligent-machine/</guid><description>Today marked the first time I was ever so uncomfortable in a class that I nearly got up and walked out. Such a level of discomfort is not so unfamiliar, though. It was, in fact, common during my review of candidates&amp;rsquo; projects during my involvement in one of my former employer&amp;rsquo;s hiring process. Someone might ask the candidate something like &amp;ldquo;How does user authorization work?&amp;rdquo; They&amp;rsquo;d drone on about encryption, throwing out buzzwords and waiting to see a spark in someone&amp;rsquo;s eye, letting them know that they weren&amp;rsquo;t a complete failure.</description></item><item><title>Interpolating Ruby Strings</title><link>http://j3rn.com/posts/2014-12-19-interpolating-ruby-strings/</link><pubDate>Fri, 19 Dec 2014 22:14:25 -0500</pubDate><guid>http://j3rn.com/posts/2014-12-19-interpolating-ruby-strings/</guid><description>Let&amp;rsquo;s talk about interpolation. Sure, you probably know the Ruby string interpolation syntax:
arg = &amp;#34;world&amp;#34; puts &amp;#34;Hello #{arg}!&amp;#34; #=&amp;gt; &amp;#34;Hello world!&amp;#34; This syntax is pretty useful. However, it has it&amp;rsquo;s limitations. Let&amp;rsquo;s say that we are generating strings that are almost the same each time, but with each, one word changes. How are you going to do this now?
My first inclination was something like this:
line = &amp;#34;Today the weather is \#{ weather }&amp;#34; weather_conditions = {} [&amp;#34;warm&amp;#34;, &amp;#34;cloudy&amp;#34;, &amp;#34;windy&amp;#34;].</description></item><item><title>Why do you dress that way?</title><link>http://j3rn.com/aesthetic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://j3rn.com/aesthetic/</guid><description>I get asked this a lot, so I wrote a glorified FAQ page. # The original reason was social engineering lite. Occasionally I would have to dress up for events in high school, and I noticed that when I did people treated me differently. There&amp;rsquo;s a ton of research into subconscious biases that&amp;rsquo;s honestly really fascinating, but suffice it to say that police officers are usually nicer to well-dressed people that they pull over.</description></item></channel></rss>