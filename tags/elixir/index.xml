<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Elixir on J3RN's Blog</title><link>https://j3rn.com/tags/elixir/</link><description>Recent content in Elixir on J3RN's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 01 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://j3rn.com/tags/elixir/index.xml" rel="self" type="application/rss+xml"/><item><title>Avoiding a GenServer Pitfall</title><link>https://j3rn.com/posts/a-genserver-pitfall/</link><pubDate>Sat, 01 Nov 2025 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/a-genserver-pitfall/</guid><description>&lt;h1 id="firstly-what-is-a-genserver" class="relative group">Firstly, what is a GenServer? &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#firstly-what-is-a-genserver" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>GenServer, short for &amp;ldquo;generic server&amp;rdquo;, is a type of process within BEAM (Erlang, Elixir) applications that can hold state and respond to requests; much like a web server, in a way. For instance, you could create a GenServer that you could handle requests to store blog posts as well as other requests to list or read those blog posts—but those request would have to be made within the BEAM VM rather than with a web browser. Within BEAM applications, the two primary purposes of GenServers are to execute code asynchronously and act as a store of shared, mutable state.&lt;/p></description></item><item><title>My API Integration Methodology</title><link>https://j3rn.com/posts/api-integration-design/</link><pubDate>Sun, 27 Jul 2025 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/api-integration-design/</guid><description>&lt;p>The code examples in this post are in Elixir, and some of the design aspects are Elixir-specific, but the concepts are translatable to most languages.&lt;/p>
&lt;p>A common aspect of modern web applications is the need to communicate with other web applications in what is usually referred to as &amp;ldquo;API integrations&amp;rdquo;. For example, consider &lt;a href="https://stripe.com" target="_blank" rel="noreferrer">Stripe&lt;/a>. Stripe is a payment processor service that handles the complicated parts of accepting payments. If your app is being extended to have a checkout experience for customers, you might integrate with Stripe to accomplish that.&lt;/p></description></item><item><title>Let it Crash?</title><link>https://j3rn.com/posts/let-it-crash/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/let-it-crash/</guid><description>&lt;p>






 
 
&lt;figure>&lt;img src="https://j3rn.com/images/titanic.webp" alt="The oceanliner Titanic sinking in the North Atlantic" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;p>In the BEAM ecosystem (&lt;a href="https://erlang.org" target="_blank" rel="noreferrer">Erlang&lt;/a>, &lt;a href="https://elixir-lang.org" target="_blank" rel="noreferrer">Elixir&lt;/a>, &lt;a href="https://gleam.run" target="_blank" rel="noreferrer">Gleam&lt;/a>, etc), there&amp;rsquo;s a common idiom:&lt;/p>
&lt;h2 id="let-it-crash" class="relative group">Let It Crash &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#let-it-crash" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>And your first reaction to this is probably astonishment, because crashing is, generally-speaking, not ideal. In traditional, single-threaded systems, a crash means that your program dies and—in server settings—it&amp;rsquo;s then the responsibility of some other service (SystemD or Kubernetes or whatever) to notice that your program has died and restart it. In the event that this process was non-redundant (which is, itself, bad), this may result in downtime. However, in BEAM languages this is usually not the case; business logic is typically executed by BEAM worker processes&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> which are isolated from all other BEAM processes. If one BEAM process crashes, all the other processes keep going&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. Furthermore, these processes are usually &amp;ldquo;supervised&amp;rdquo; by a &lt;a href="https://www.erlang.org/doc/man/supervisor" target="_blank" rel="noreferrer">Supervisor&lt;/a> which will detect the crash and start a replacement process, if necessary.&lt;/p></description></item><item><title>Debugging Elixir with Erlang's dbg</title><link>https://j3rn.com/posts/debugging-with-dbg/</link><pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/debugging-with-dbg/</guid><description>&lt;p>Sometimes, either in local development or on a production server, you want to see when a given function is called, what arguments it is being called with, and what it&amp;rsquo;s returning. Let&amp;rsquo;s say that you have a &lt;code>MyApp.Widgets.show_widget?/1&lt;/code> function which consumes a widget and returns a boolean indicating whether or not that widget should be shown to the user. However, the logic contained in there is pretty complicated and—worse—you don&amp;rsquo;t know really where it is called from anyway.&lt;/p></description></item><item><title>Elixir GenServers vs Agents</title><link>https://j3rn.com/posts/genserver-vs-agent/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/genserver-vs-agent/</guid><description>&lt;p>Just as &lt;a href="https://j3rn.com/posts/2021-10-14-elixir-behaviours-vs-protocols">Protocols are an abstraction built upon Behaviours&lt;/a>, Agents are an abstraction built upon GenServers. While GenServers can serve a wider variety of purposes, Agents serve a single purpose: storing state.&lt;/p>
&lt;h2 id="genserver" class="relative group">GenServer &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#genserver" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>The &lt;a href="https://hexdocs.pm/elixir/1.13.4/GenServer.html" target="_blank" rel="noreferrer">Elixir documentation for GenServer&lt;/a> summarizes them as such:&lt;/p>
&lt;blockquote>
&lt;p>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.&lt;/p></description></item><item><title>Profiling Elixir for Advent of Code</title><link>https://j3rn.com/posts/profiling-elixir-for-advent-of-code/</link><pubDate>Sun, 05 Dec 2021 15:34:07 -0500</pubDate><guid>https://j3rn.com/posts/profiling-elixir-for-advent-of-code/</guid><description>&lt;p>Every now and again, you may run into a problem that isn&amp;rsquo;t hard to solve using functional programming, but which is hard to solve &lt;em>quickly&lt;/em> using functional programming. For me, today, that problem was &lt;a href="https://adventofcode.com/2021/" target="_blank" rel="noreferrer">Advent of Code&lt;/a>, &lt;a href="https://adventofcode.com/2021/day/5" target="_blank" rel="noreferrer">Day 5&lt;/a>.&lt;/p>
&lt;p>If you&amp;rsquo;re participating in Advent of Code and you haven&amp;rsquo;t yet solved Day 5, this is your last chance to leave the page without spoilers. You have been warned!&lt;/p>
&lt;h2 id="the-problem" class="relative group">The Problem &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#the-problem" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>You are provided with a list of lines of hydrothermal vents on the ocean floor. These lines are represented by start and end coordinates, such as &lt;code>0,9 -&amp;gt; 5,9&lt;/code>. In this example, this means that there are hydrothermal vents at coordinates &lt;code>0,9&lt;/code>, &lt;code>1,9&lt;/code>, &lt;code>2,9&lt;/code>, &lt;code>3,9&lt;/code>, &lt;code>4,9&lt;/code>, and &lt;code>5,9&lt;/code>. Interestingly, two &amp;ldquo;lines&amp;rdquo; of vents may intersect or overlap, which create areas of increased concern.&lt;/p></description></item><item><title>Elixir Behaviours vs Protocols</title><link>https://j3rn.com/posts/elixir-behaviours-vs-protocols/</link><pubDate>Thu, 14 Oct 2021 22:40:42 -0400</pubDate><guid>https://j3rn.com/posts/elixir-behaviours-vs-protocols/</guid><description>&lt;p>As developers begin learning Elixir, they often have a very understandable confusion around the difference between Elixir&amp;rsquo;s &lt;a href="https://hexdocs.pm/elixir/typespecs.html#behaviours" target="_blank" rel="noreferrer">behaviours&lt;/a> and &lt;a href="https://hexdocs.pm/elixir/Protocol.html" target="_blank" rel="noreferrer">protocols&lt;/a>. These are similar constructs, but with important differences.&lt;/p>
&lt;h2 id="behaviours" class="relative group">Behaviours &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#behaviours" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Behaviours are conceptually quite simple:&lt;/p>
&lt;blockquote>
&lt;p>A behaviour module defines a set of functions and macros (referred to as callbacks) that callback modules implementing that behaviour must export.&lt;/p>&lt;/blockquote>
&lt;p>For instance, a commonly used behaviour is GenServer, used like so:&lt;/p></description></item><item><title>Exciting Changes Coming in Elixir 1.12</title><link>https://j3rn.com/posts/elixir-1.12/</link><pubDate>Wed, 14 Apr 2021 15:10:00 -0500</pubDate><guid>https://j3rn.com/posts/elixir-1.12/</guid><description>&lt;p>José recently &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v1.12.0-rc.0" target="_blank" rel="noreferrer">announced the availability of Elixir 1.12.0 rc.0&lt;/a>, a precursor to the full Elixir 1.12.0 release which should come within the next month or so. This update consists primarily of developer quality-of-life improvements. In his announcement, José elaborated on a few changes, but I couldn&amp;rsquo;t help but feel that some exciting changes were relegated to footnotes. As such, I&amp;rsquo;m dedicating this post to trawling through the full changelog and shining a spotlight on a few of my favorite changes.&lt;/p></description></item><item><title>The Harmful Duality of Elixir's nil</title><link>https://j3rn.com/posts/harmful-duality-of-elixirs-nil/</link><pubDate>Sun, 13 Dec 2020 20:46:00 -0500</pubDate><guid>https://j3rn.com/posts/harmful-duality-of-elixirs-nil/</guid><description>&lt;h3 id="the-problem" class="relative group">The Problem &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#the-problem" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>Have you ever written code like this?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">def&lt;/span> &lt;span style="color:#c1abea">get_address&lt;/span>(&lt;span style="color:#c1abea">address_id&lt;/span>) &lt;span style="color:#c678dd">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">case&lt;/span> &lt;span style="color:#76a9f9">Addresses&lt;/span>&lt;span style="color:#c7bf54">.&lt;/span>&lt;span style="color:#c1abea">get&lt;/span>(&lt;span style="color:#c1abea">address_id&lt;/span>) &lt;span style="color:#c678dd">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b756ff;font-weight:bold">nil&lt;/span> &lt;span style="color:#c7bf54">-&amp;gt;&lt;/span> {&lt;span style="color:#56b6c2">:error&lt;/span>, &lt;span style="color:#56b6c2">:address_not_found&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c1abea">val&lt;/span> &lt;span style="color:#c7bf54">-&amp;gt;&lt;/span> {&lt;span style="color:#56b6c2">:ok&lt;/span>, &lt;span style="color:#c1abea">val&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I have. This pattern is commonly used to make the value that &lt;a href="https://hexdocs.pm/ecto/Ecto.Repo.html#c:get/3" target="_blank" rel="noreferrer">Ecto.Repo.get/3&lt;/a> returns (a struct or &lt;code>nil&lt;/code>) play well with Elixir&amp;rsquo;s &lt;a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="noreferrer">&lt;code>with&lt;/code>&lt;/a> construct. Since &lt;code>Ecto.Repo.get/3&lt;/code> will always return some single value, a &lt;code>nil&lt;/code> check is required to determine whether that value indicates a success or a failure. Doing this check inline is somewhat clumsy:&lt;/p></description></item></channel></rss>