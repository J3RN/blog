<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Elixir on J3RN's Blog</title><link>http://j3rn.com/tags/elixir/</link><description>Recent content in Elixir on J3RN's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 12 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://j3rn.com/tags/elixir/index.xml" rel="self" type="application/rss+xml"/><item><title>Let it Crash?</title><link>http://j3rn.com/posts/let-it-crash/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/let-it-crash/</guid><description>&lt;p>






 
 
&lt;figure>&lt;img src="http://j3rn.com/images/titanic.webp" alt="The oceanliner Titanic sinking in the North Atlantic" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;p>In the BEAM ecosystem (&lt;a href="https://erlang.org" target="_blank" rel="noreferrer">Erlang&lt;/a>, &lt;a href="https://elixir-lang.org" target="_blank" rel="noreferrer">Elixir&lt;/a>, &lt;a href="https://gleam.run" target="_blank" rel="noreferrer">Gleam&lt;/a>, etc), there&amp;rsquo;s a common idiom:&lt;/p>
&lt;h2 id="let-it-crash" class="relative group">Let It Crash &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#let-it-crash" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>And your first reaction to this is probably astonishment, because crashing is, generally-speaking, not ideal. In traditional, single-threaded systems, a crash means that your program dies and—in server settings—it&amp;rsquo;s then the responsibility of some other service (SystemD or Kubernetes or whatever) to notice that your program has died and restart it. In the event that this process was non-redundant (which is, itself, bad), this may result in downtime. However, in BEAM languages this is usually not the case; business logic is typically executed by BEAM worker processes&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> which are isolated from all other BEAM processes. If one BEAM process crashes, all the other processes keep going&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. Furthermore, these processes are usually &amp;ldquo;supervised&amp;rdquo; by a &lt;a href="https://www.erlang.org/doc/man/supervisor" target="_blank" rel="noreferrer">Supervisor&lt;/a> which will detect the crash and start a replacement process, if necessary.&lt;/p></description></item><item><title>Debugging Elixir with Erlang's dbg</title><link>http://j3rn.com/posts/debugging-with-dbg/</link><pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/debugging-with-dbg/</guid><description>&lt;p>Sometimes, either in local development or on a production server, you want to see when a given function is called, what arguments it is being called with, and what it&amp;rsquo;s returning. Let&amp;rsquo;s say that you have a &lt;code>MyApp.Widgets.show_widget?/1&lt;/code> function which consumes a widget and returns a boolean indicating whether or not that widget should be shown to the user. However, the logic contained in there is pretty complicated and—worse—you don&amp;rsquo;t know really where it is called from anyway.&lt;/p></description></item><item><title>Elixir GenServers vs Agents</title><link>http://j3rn.com/posts/genserver-vs-agent/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/genserver-vs-agent/</guid><description>&lt;p>Just as &lt;a href="http://j3rn.com/posts/2021-10-14-elixir-behaviours-vs-protocols">Protocols are an abstraction built upon Behaviours&lt;/a>, Agents are an abstraction built upon GenServers. While GenServers can serve a wider variety of purposes, Agents serve a single purpose: storing state.&lt;/p>
&lt;h2 id="genserver" class="relative group">GenServer &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#genserver" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>The &lt;a href="https://hexdocs.pm/elixir/1.13.4/GenServer.html" target="_blank" rel="noreferrer">Elixir documentation for GenServer&lt;/a> summarizes them as such:&lt;/p>
&lt;blockquote>
&lt;p>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.&lt;/p></description></item><item><title>Profiling Elixir for Advent of Code</title><link>http://j3rn.com/posts/profiling-elixir-for-advent-of-code/</link><pubDate>Sun, 05 Dec 2021 15:34:07 -0500</pubDate><guid>http://j3rn.com/posts/profiling-elixir-for-advent-of-code/</guid><description>&lt;p>Every now and again, you may run into a problem that isn&amp;rsquo;t hard to solve using functional programming, but which is hard to solve &lt;em>quickly&lt;/em> using functional programming. For me, today, that problem was &lt;a href="https://adventofcode.com/2021/" target="_blank" rel="noreferrer">Advent of Code&lt;/a>, &lt;a href="https://adventofcode.com/2021/day/5" target="_blank" rel="noreferrer">Day 5&lt;/a>.&lt;/p>
&lt;p>If you&amp;rsquo;re participating in Advent of Code and you haven&amp;rsquo;t yet solved Day 5, this is your last chance to leave the page without spoilers. You have been warned!&lt;/p>
&lt;h2 id="the-problem" class="relative group">The Problem &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#the-problem" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>You are provided with a list of lines of hydrothermal vents on the ocean floor. These lines are represented by start and end coordinates, such as &lt;code>0,9 -&amp;gt; 5,9&lt;/code>. In this example, this means that there are hydrothermal vents at coordinates &lt;code>0,9&lt;/code>, &lt;code>1,9&lt;/code>, &lt;code>2,9&lt;/code>, &lt;code>3,9&lt;/code>, &lt;code>4,9&lt;/code>, and &lt;code>5,9&lt;/code>. Interestingly, two &amp;ldquo;lines&amp;rdquo; of vents may intersect or overlap, which create areas of increased concern.&lt;/p></description></item><item><title>Elixir Behaviours vs Protocols</title><link>http://j3rn.com/posts/elixir-behaviours-vs-protocols/</link><pubDate>Thu, 14 Oct 2021 22:40:42 -0400</pubDate><guid>http://j3rn.com/posts/elixir-behaviours-vs-protocols/</guid><description>&lt;p>As developers begin learning Elixir, they often have a very understandable confusion around the difference between Elixir&amp;rsquo;s &lt;a href="https://hexdocs.pm/elixir/typespecs.html#behaviours" target="_blank" rel="noreferrer">behaviours&lt;/a> and &lt;a href="https://hexdocs.pm/elixir/Protocol.html" target="_blank" rel="noreferrer">protocols&lt;/a>. These are similar constructs, but with important differences.&lt;/p>
&lt;h2 id="behaviours" class="relative group">Behaviours &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#behaviours" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Behaviours are conceptually quite simple:&lt;/p>
&lt;blockquote>
&lt;p>A behaviour module defines a set of functions and macros (referred to as callbacks) that callback modules implementing that behaviour must export.&lt;/p>
&lt;/blockquote>
&lt;p>For instance, a commonly used behaviour is GenServer, used like so:&lt;/p></description></item><item><title>Exciting Changes Coming in Elixir 1.12</title><link>http://j3rn.com/posts/elixir-1.12/</link><pubDate>Wed, 14 Apr 2021 15:10:00 -0500</pubDate><guid>http://j3rn.com/posts/elixir-1.12/</guid><description>&lt;p>José recently &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v1.12.0-rc.0" target="_blank" rel="noreferrer">announced the availability of Elixir 1.12.0 rc.0&lt;/a>, a precursor to the full Elixir 1.12.0 release which should come within the next month or so. This update consists primarily of developer quality-of-life improvements. In his announcement, José elaborated on a few changes, but I couldn&amp;rsquo;t help but feel that some exciting changes were relegated to footnotes. As such, I&amp;rsquo;m dedicating this post to trawling through the full changelog and shining a spotlight on a few of my favorite changes.&lt;/p></description></item><item><title>The Harmful Duality of Elixir's nil</title><link>http://j3rn.com/posts/harmful-duality-of-elixirs-nil/</link><pubDate>Sun, 13 Dec 2020 20:46:00 -0500</pubDate><guid>http://j3rn.com/posts/harmful-duality-of-elixirs-nil/</guid><description>&lt;h3 id="the-problem" class="relative group">The Problem &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#the-problem" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>Have you ever written code like this?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">def&lt;/span> &lt;span style="color:#c1abea">get_address&lt;/span>(&lt;span style="color:#c1abea">address_id&lt;/span>) &lt;span style="color:#c678dd">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">case&lt;/span> &lt;span style="color:#76a9f9">Addresses&lt;/span>&lt;span style="color:#c7bf54">.&lt;/span>&lt;span style="color:#c1abea">get&lt;/span>(&lt;span style="color:#c1abea">address_id&lt;/span>) &lt;span style="color:#c678dd">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b756ff;font-weight:bold">nil&lt;/span> &lt;span style="color:#c7bf54">-&amp;gt;&lt;/span> {&lt;span style="color:#56b6c2">:error&lt;/span>, &lt;span style="color:#56b6c2">:address_not_found&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c1abea">val&lt;/span> &lt;span style="color:#c7bf54">-&amp;gt;&lt;/span> {&lt;span style="color:#56b6c2">:ok&lt;/span>, &lt;span style="color:#c1abea">val&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I have. This pattern is commonly used to make the value that &lt;a href="https://hexdocs.pm/ecto/Ecto.Repo.html#c:get/3" target="_blank" rel="noreferrer">Ecto.Repo.get/3&lt;/a> returns (a struct or &lt;code>nil&lt;/code>) play well with Elixir&amp;rsquo;s &lt;a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1" target="_blank" rel="noreferrer">&lt;code>with&lt;/code>&lt;/a> construct. Since &lt;code>Ecto.Repo.get/3&lt;/code> will always return some single value, a &lt;code>nil&lt;/code> check is required to determine whether that value indicates a success or a failure. Doing this check inline is somewhat clumsy:&lt;/p></description></item></channel></rss>