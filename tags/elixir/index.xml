<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>elixir on J3RN's Blog</title><link>http://j3rn.com/tags/elixir/</link><description>Recent content in elixir on J3RN's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://j3rn.com/tags/elixir/index.xml" rel="self" type="application/rss+xml"/><item><title>Debugging Elixir with Erlang's dbg</title><link>http://j3rn.com/posts/debugging-with-dbg/</link><pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/debugging-with-dbg/</guid><description>Sometimes, either in local development or on a production server, you want to see when a given function is called, what arguments it is being called with, and what it&amp;rsquo;s returning. Let&amp;rsquo;s say that you have a MyApp.Widgets.show_widget?/1 function which consumes a widget and returns a boolean indicating whether or not that widget should be shown to the user. However, the logic contained in there is pretty complicated and—worse—you don&amp;rsquo;t know really where it is called from anyway.</description></item><item><title>Elixir GenServers vs Agents</title><link>http://j3rn.com/posts/genserver-vs-agent/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/genserver-vs-agent/</guid><description>Just as Protocols are an abstraction built upon Behaviours, Agents are an abstraction built upon GenServers. While GenServers can serve a wider variety of purposes, Agents serve a single purpose: storing state.
GenServer #The Elixir documentation for GenServer summarizes them as such:
A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting.</description></item><item><title>Profiling Elixir for Advent of Code</title><link>http://j3rn.com/posts/profiling-elixir-for-advent-of-code/</link><pubDate>Sun, 05 Dec 2021 15:34:07 -0500</pubDate><guid>http://j3rn.com/posts/profiling-elixir-for-advent-of-code/</guid><description>Every now and again, you may run into a problem that isn&amp;rsquo;t hard to solve using functional programming, but which is hard to solve quickly using functional programming. For me, today, that problem was Advent of Code, Day 5.
If you&amp;rsquo;re participating in Advent of Code and you haven&amp;rsquo;t yet solved Day 5, this is your last chance to leave the page without spoilers. You have been warned!
The Problem #You are provided with a list of lines of hydrothermal vents on the ocean floor.</description></item><item><title>Elixir Behaviours vs Protocols</title><link>http://j3rn.com/posts/elixir-behaviours-vs-protocols/</link><pubDate>Thu, 14 Oct 2021 22:40:42 -0400</pubDate><guid>http://j3rn.com/posts/elixir-behaviours-vs-protocols/</guid><description>As developers begin learning Elixir, they often have a very understandable confusion around the difference between Elixir&amp;rsquo;s behaviours and protocols. These are similar constructs, but with important differences.
Behaviours #Behaviours are conceptually quite simple:
A behaviour module defines a set of functions and macros (referred to as callbacks) that callback modules implementing that behaviour must export.
For instance, a commonly used behaviour is GenServer, used like so:
defmodule MyApp.APICache do @behaviour GenServer end However, this module fails to compile with the following error:</description></item><item><title>Exciting Changes Coming in Elixir 1.12</title><link>http://j3rn.com/posts/elixir-1.12/</link><pubDate>Wed, 14 Apr 2021 15:10:00 -0500</pubDate><guid>http://j3rn.com/posts/elixir-1.12/</guid><description>José recently announced the availability of Elixir 1.12.0 rc.0, a precursor to the full Elixir 1.12.0 release which should come within the next month or so. This update consists primarily of developer quality-of-life improvements. In his announcement, José elaborated on a few changes, but I couldn&amp;rsquo;t help but feel that some exciting changes were relegated to footnotes. As such, I&amp;rsquo;m dedicating this post to trawling through the full changelog and shining a spotlight on a few of my favorite changes.</description></item><item><title>The Harmful Duality of Elixir's nil</title><link>http://j3rn.com/posts/harmful-duality-of-elixirs-nil/</link><pubDate>Sun, 13 Dec 2020 20:46:00 -0500</pubDate><guid>http://j3rn.com/posts/harmful-duality-of-elixirs-nil/</guid><description>The Problem #Have you ever written code like this?
def get_address(address_id) do case Addresses.get(address_id) do nil -&amp;gt; {:error, :address_not_found} val -&amp;gt; {:ok, val} end end I have. This pattern is commonly used to make the value that Ecto.Repo.get/3 returns (a struct or nil) play well with Elixir&amp;rsquo;s with construct. Since Ecto.Repo.get/3 will always return some single value, a nil check is required to determine whether that value indicates a success or a failure.</description></item></channel></rss>