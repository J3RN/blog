<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Databases on J3RN's Blog</title><link>http://j3rn.com/tags/databases/</link><description>Recent content in Databases on J3RN's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 11 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://j3rn.com/tags/databases/index.xml" rel="self" type="application/rss+xml"/><item><title>The Four Part Migration</title><link>http://j3rn.com/posts/the-four-part-migration/</link><pubDate>Thu, 11 May 2023 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/the-four-part-migration/</guid><description>&lt;p>If you&amp;rsquo;ve been writing relational database-backed applications for long enough, you&amp;rsquo;ve needed this. The situation is common enough: You have a some kind of web application, you don&amp;rsquo;t want to have any downtime, and you need to make a breaking change to your schema.&lt;/p>
&lt;p>Breaking changes come in several forms: renaming a column, changing its type, or even just changing the format in which you store data (e.g. normalizing phone numbers), etc. What these cases have in common is that once the change is made, the code that relied on the way that things were will no longer function. For instance, when a column is renamed, code that&amp;rsquo;s looking for the data under the old name won&amp;rsquo;t work. Code looking for data under the &lt;em>new&lt;/em> name won&amp;rsquo;t function either until the rename is complete.&lt;/p></description></item></channel></rss>