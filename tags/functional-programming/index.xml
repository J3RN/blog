<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>functional programming on J3RN's Blog</title><link>http://j3rn.com/tags/functional-programming/</link><description>Recent content in functional programming on J3RN's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 13 Dec 2020 20:46:00 -0500</lastBuildDate><atom:link href="http://j3rn.com/tags/functional-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>The Harmful Duality of Elixir's nil</title><link>http://j3rn.com/posts/harmful-duality-of-elixirs-nil/</link><pubDate>Sun, 13 Dec 2020 20:46:00 -0500</pubDate><guid>http://j3rn.com/posts/harmful-duality-of-elixirs-nil/</guid><description>The Problem # Have you ever written code like this?
def get_address(address_id) do case Addresses.get(address_id) do nil -&amp;gt; {:error, :address_not_found} val -&amp;gt; {:ok, val} end end I have. This pattern is commonly used to make the value that Ecto.Repo.get/3 returns (a struct or nil) play well with Elixir&amp;rsquo;s with construct. Since Ecto.Repo.get/3 will always return some single value, a nil check is required to determine whether that value indicates a success or a failure.</description></item></channel></rss>