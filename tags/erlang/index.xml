<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Erlang on J3RN's Blog</title><link>https://j3rn.com/tags/erlang/</link><description>Recent content in Erlang on J3RN's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 13 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://j3rn.com/tags/erlang/index.xml" rel="self" type="application/rss+xml"/><item><title>Object Orientation and the Limits of Metaphor</title><link>https://j3rn.com/posts/object-orientation-limits-of-metaphor/</link><pubDate>Sun, 13 Apr 2025 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/object-orientation-limits-of-metaphor/</guid><description>&lt;p>Roughly ten years ago, I was very excited about object orientation. Which made me somewhat late to the party; glowing pronouncements of how object orientation was going to solve the software complexity crisis had flooded industry publications some two decades prior. Regardless, in 2014, I was trying to explain to a friend why objects were so grand.&lt;/p>
&lt;p>&amp;ldquo;Objects model the real world,&amp;rdquo; I said, grabbing a pencil off the table and holding it up. &amp;ldquo;For instance, I could create a Pencil class, representing the Platonic idea of Pencil, and this would be an instance of it.&amp;rdquo; I, like any modern person, did not actually subscribe to Platonism. &amp;ldquo;And it&amp;rsquo;s able to &lt;em>do&lt;/em> stuff, which we refer to as &amp;lsquo;methods&amp;rsquo;. For instance,&amp;rdquo; I said, scribbling on a piece of paper, &amp;ldquo;it might have a &amp;lsquo;write&amp;rsquo; method, for writing things.&amp;rdquo;&lt;/p></description></item><item><title>Let it Crash?</title><link>https://j3rn.com/posts/let-it-crash/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/let-it-crash/</guid><description>&lt;p>






 
 
&lt;figure>&lt;img src="https://j3rn.com/images/titanic.webp" alt="The oceanliner Titanic sinking in the North Atlantic" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;p>In the BEAM ecosystem (&lt;a href="https://erlang.org" target="_blank" rel="noreferrer">Erlang&lt;/a>, &lt;a href="https://elixir-lang.org" target="_blank" rel="noreferrer">Elixir&lt;/a>, &lt;a href="https://gleam.run" target="_blank" rel="noreferrer">Gleam&lt;/a>, etc), there&amp;rsquo;s a common idiom:&lt;/p>
&lt;h2 id="let-it-crash" class="relative group">Let It Crash &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#let-it-crash" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>And your first reaction to this is probably astonishment, because crashing is, generally-speaking, not ideal. In traditional, single-threaded systems, a crash means that your program dies and—in server settings—it&amp;rsquo;s then the responsibility of some other service (SystemD or Kubernetes or whatever) to notice that your program has died and restart it. In the event that this process was non-redundant (which is, itself, bad), this may result in downtime. However, in BEAM languages this is usually not the case; business logic is typically executed by BEAM worker processes&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> which are isolated from all other BEAM processes. If one BEAM process crashes, all the other processes keep going&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. Furthermore, these processes are usually &amp;ldquo;supervised&amp;rdquo; by a &lt;a href="https://www.erlang.org/doc/man/supervisor" target="_blank" rel="noreferrer">Supervisor&lt;/a> which will detect the crash and start a replacement process, if necessary.&lt;/p></description></item><item><title>Debugging Elixir with Erlang's dbg</title><link>https://j3rn.com/posts/debugging-with-dbg/</link><pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/debugging-with-dbg/</guid><description>&lt;p>Sometimes, either in local development or on a production server, you want to see when a given function is called, what arguments it is being called with, and what it&amp;rsquo;s returning. Let&amp;rsquo;s say that you have a &lt;code>MyApp.Widgets.show_widget?/1&lt;/code> function which consumes a widget and returns a boolean indicating whether or not that widget should be shown to the user. However, the logic contained in there is pretty complicated and—worse—you don&amp;rsquo;t know really where it is called from anyway.&lt;/p></description></item></channel></rss>