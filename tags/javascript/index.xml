<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascript on J3RN's Blog</title><link>https://j3rn.com/tags/javascript/</link><description>Recent content in Javascript on J3RN's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 04 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://j3rn.com/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Why I Still Use JavaScript's then</title><link>https://j3rn.com/posts/javascript-prefer-then/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate><guid>https://j3rn.com/posts/javascript-prefer-then/</guid><description>&lt;p>With ECMAScript 2017, JavaScript gained the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function" target="_blank" rel="noreferrer">&lt;code>async&lt;/code>&lt;/a> and &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noreferrer">&lt;code>await&lt;/code>&lt;/a> keywords as a new way to deal with &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noreferrer">Promise&lt;/a>s. The traditional way to work with Promises was with the methods &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noreferrer">&lt;code>then&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" target="_blank" rel="noreferrer">&lt;code>catch&lt;/code>&lt;/a>, and &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally" target="_blank" rel="noreferrer">&lt;code>finally&lt;/code>&lt;/a>, like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#c678dd">const&lt;/span> &lt;span style="color:#c1abea">fetchResource&lt;/span> &lt;span style="color:#c7bf54">=&lt;/span> () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#c678dd">return&lt;/span> &lt;span style="color:#c1abea">fetch&lt;/span>(&lt;span style="color:#63c381">&amp;#34;https://example.com/api/resource&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#c1abea">then&lt;/span>((&lt;span style="color:#c1abea">res&lt;/span>) =&amp;gt; &lt;span style="color:#c1abea">handleResponse&lt;/span>(&lt;span style="color:#c1abea">res&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#c678dd">catch&lt;/span>((&lt;span style="color:#c1abea">err&lt;/span>) =&amp;gt; &lt;span style="color:#c1abea">handleError&lt;/span>(&lt;span style="color:#c1abea">err&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#c678dd">finally&lt;/span>(() =&amp;gt; &lt;span style="color:#c1abea">cleanup&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above function:&lt;/p>
&lt;ul>
&lt;li>fetches a data from a server using the venerable &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noreferrer">&lt;code>fetch&lt;/code>&lt;/a> function, which returns a Promise,&lt;/li>
&lt;li>calls the &lt;code>then&lt;/code> method on the Promise returned from &lt;code>fetch&lt;/code> to configure it such that if the Promise &amp;ldquo;resolves&amp;rdquo; (completes successfully), the &lt;code>handleResponse&lt;/code> function is invoked with the &amp;ldquo;resolved&amp;rdquo; value (here, an HTTP response),&lt;/li>
&lt;li>calls the &lt;code>catch&lt;/code> method on the Promise returned from &lt;code>then&lt;/code> which configures it such that if the Promise &amp;ldquo;rejects&amp;rdquo; (is unsuccessful), the &lt;code>handleError&lt;/code> is invoked with the reject value (some kind of error),&lt;/li>
&lt;li>calls the &lt;code>finally&lt;/code> method on the Promise returned from &lt;code>catch&lt;/code> which configures it such that the &lt;code>cleanup&lt;/code> function is always invoked regardless of whether the Promise resolves or rejects.&lt;/li>
&lt;/ul>
&lt;p>Technically, the &lt;code>catch&lt;/code> and &lt;code>finally&lt;/code> method are wrappers around &lt;code>then&lt;/code> that specialize it for different scenarios and allow programmers to convey intent more easily.&lt;/p></description></item></channel></rss>