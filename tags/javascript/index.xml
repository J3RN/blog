<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on J3RN's Blog</title><link>http://j3rn.com/tags/javascript/</link><description>Recent content in javascript on J3RN's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 04 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://j3rn.com/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Why I Still Use JavaScript's then</title><link>http://j3rn.com/posts/javascript-prefer-then/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/javascript-prefer-then/</guid><description>With ECMAScript 2017, JavaScript gained the async and await keywords as a new way to deal with Promises. The traditional way to work with Promises was with the methods then, catch, and finally, like so:
const fetchResource = () =&amp;gt; { return fetch(&amp;#34;https://example.com/api/resource&amp;#34;) .then((res) =&amp;gt; handleResponse(res)) .catch((err) =&amp;gt; handleError(err)) .finally(() =&amp;gt; cleanup()); }; The above function:
fetches a data from a server using the venerable fetch function, which returns a Promise, calls the then method on the Promise returned from fetch to configure it such that if the Promise &amp;ldquo;resolves&amp;rdquo; (completes successfully), the handleResponse function is invoked with the &amp;ldquo;resolved&amp;rdquo; value (here, an HTTP response), calls the catch method on the Promise returned from then which configures it such that if the Promise &amp;ldquo;rejects&amp;rdquo; (is unsuccessful), the handleError is invoked with the reject value (some kind of error), calls the finally method on the Promise returned from catch which configures it such that the cleanup function is always invoked regardless of whether the Promise resolves or rejects.</description></item></channel></rss>