<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ruby on J3RN's Blog</title><link>http://j3rn.com/tags/ruby/</link><description>Recent content in ruby on J3RN's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 13 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="http://j3rn.com/tags/ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>Object Orientation and the Limits of Metaphor</title><link>http://j3rn.com/posts/object-orientation-limits-of-metaphor/</link><pubDate>Sun, 13 Apr 2025 00:00:00 +0000</pubDate><guid>http://j3rn.com/posts/object-orientation-limits-of-metaphor/</guid><description>Roughly ten years ago, I was very excited about object orientation. Which made me somewhat late to the party; glowing pronouncements of how object orientation was going to solve the software complexity crisis had flooded industry publications some two decades prior. Regardless, in 2014, I was trying to explain to a friend why objects were so grand.
&amp;ldquo;Objects model the real world,&amp;rdquo; I said, grabbing a pencil off the table and holding it up.</description></item><item><title>Escaping from Ruby Blocks</title><link>http://j3rn.com/posts/escaping-from-ruby-blocks/</link><pubDate>Wed, 18 Oct 2017 12:00:00 -0400</pubDate><guid>http://j3rn.com/posts/escaping-from-ruby-blocks/</guid><description>Guard Clauses #Once upon a time, Rubocop taught me to love guard clauses. When I first started learning to program, I was deeply conflicted about guard clauses. On the one hand, guard clauses can prevent the need to have deeply nested ifs. On the other hand, it can be hard to remember the context deep into a method without being able to reference the enveloping ifs (similarly to RSpec contexts). In any case, Rubocop wants me to use guard clauses, so I do.</description></item><item><title>To Monkey Patch Ruby</title><link>http://j3rn.com/posts/to-monkey-patch-ruby/</link><pubDate>Thu, 25 Aug 2016 16:07:49 -0400</pubDate><guid>http://j3rn.com/posts/to-monkey-patch-ruby/</guid><description>This is the first of a series of posts I intend to write in a new &amp;ldquo;J3RN vs J3RN&amp;rdquo; style. Essentially, I will be stating a problem with two or more possible solutions, taking both sides in turn, and hopefully ultimately reaching a well thought out solution to the problem.
The Problem #For my Time Tracker application, I want to have a pretty date and time picker. However, Ruby only natively understands a handful of formats and &amp;ldquo;American date&amp;rdquo;, the format used by the pretty date and time picker, is not one of them.</description></item><item><title>Interpolating Ruby Strings</title><link>http://j3rn.com/posts/interpolating-ruby-strings/</link><pubDate>Fri, 19 Dec 2014 22:14:25 -0500</pubDate><guid>http://j3rn.com/posts/interpolating-ruby-strings/</guid><description>Let&amp;rsquo;s talk about interpolation. Sure, you probably know the Ruby string interpolation syntax:
arg = &amp;#34;world&amp;#34; puts &amp;#34;Hello #{arg}!&amp;#34; #=&amp;gt; &amp;#34;Hello world!&amp;#34; This syntax is pretty useful. However, it has it&amp;rsquo;s limitations. Let&amp;rsquo;s say that we are generating strings that are almost the same each time, but with each, one word changes. How are you going to do this now?
My first inclination was something like this:
line = &amp;#34;Today the weather is \#{ weather }&amp;#34; weather_conditions = {} [&amp;#34;warm&amp;#34;, &amp;#34;cloudy&amp;#34;, &amp;#34;windy&amp;#34;].</description></item></channel></rss>